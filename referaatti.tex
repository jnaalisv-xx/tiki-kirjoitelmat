
% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage{ae,aecompl}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{graphicx}

% juhon paketti
\usepackage{verbatim}

\begin{document}
\title{Lyhyt johdatus funktionaaliseen ohjelmointiin}
\author{Juho Naalisvaara}
\date{\today}
\level{Tieteellisen kirjoittamisen kurssin referaatti}
\maketitle
\pagenumbering{arabic}

% tämä poistaa sivun sivunumeron
%\thispagestyle{empty} 

\onehalfspacing

% JOHDANTO
% Funktionaalinen ohjelmointi on lausekkeiden sievennystä
\textit{Funktionaalinen ohjelmointiparadigma} on ohjelmointitapa, jossa ohjelma rakennetaan funktioista, jotka palauttavat aina saman arvon samoilla argumenteilla. Puhtaassa funktionaalisessa ohjelmoinnissa ei ole tilaa, eikä siinä suoriteta peräkkäisiä käskyjä kuten proseduraalisessa- tai olio-ohjelmoinnissa. Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan sieventämällä funktioita sisältävää lauseketta \textit{Lambda-kalkyyliin} perustuvien sievennysääntöjen mukaan. Sievennyssäännöt mahdollistavat funktioiden välittämisen argumentteina, jolloin funktiot ovat niin sanottuja \textit{ensimmäisen luokan olioita}. Funktiot jotka saavat argumentteinaan toisia funktioita, kutsutaan \textit{korkeamman asteen funktioiksi}. Niitä voidaan voidaan myös rakentaa ajonaikana ja palauttaa toisten funktioiden arvoina.

%% HISTORIAA JA LISP
Ensimmäinen funktionaalinen ohjelmointikieli oli listojen käsittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1958 John Mccarty \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispissä (kuten lähes kaikissa funktionaalisissa kielissä) on perustietorakenteena lista ja alkeisoperaattoreina funktiot jotka palauttavat listan ensimmäisen solmun tai listan hännän. Mcarthy perusti kielensä Alonzo Churchin 1932 kehittämään Lambda-kalkyyliin \cite{lambda} s.5.

%% LAMBDA KALKYYLI
Lambda-kalkyyli kehitettiin formalismiksi matemaattisten funktioiden määrittelyyn.(Ja laskettavuuden määrittelyyn?) Ilmaisuvoimaltaan se on yhtäläinen turingin koneiden kanssa \cite{lambda} s.5. Lambda-kalkyylissa funktioita ja niiden sovelluksia sisältäviä lausekkeita sievennetään kunnes päästään normaalimuotoon, eli lauseketta ei voi enää sieventää. Tämä normaalimuoto on lambda-laskennan tulos. Lambda-kalkyyli on hyvin yksinkertainen mutta ilmaisuvoimainen sievennyssäännöstö.

%Lambda-kalkyylissa funktiot esitetään \textit{lambda-abstraktioina} ja \textit{sovellus} mahdollistaa määriteltyjen funktioiden soveltamisen. \textit{Muuttujaan} voidaan sitoa mikä tahansa lambda-lauseke
% ja lambda-kalkyyli onkin sievennysjärjestelmä lambda-lausekkeille. Lambda-lauseke koostuu muuttujista, vakioista ja funktion sovelluksista. 

%% FUNKTIONAALISIA KIELIÄ
Muita funktionaaliseen ohjelmointiin sovelutuvia kieliä ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. Näistä ainoastaan Haskell on \textit{puhdas} funktionaalinen kieli. Muut kielet ovat joko multiparadigmakieliä tai mahdollistavat piirteitä jotka eivät kuulu funktionaaliseen ohjelmointiin. Esimerkiksi Schemessä on \textit{Let-lause} jonka avulla voi määritellä muuttujia. Erlang on Ericsonin kehittämä tosiaikaohjelmointiin soveltuva kieli. Scala on java-alustalla toimiva kieli

% TODO: viite haskell raporttiin
%Haskell on alusta lähtien suunniteltu puhtaaksi funktionaaliseksi ohjelmointikieleksi. 

%% FUNKTIONAALISEN OHJELMOINNIN ERITYISPIIRTEITÄ
Funktionaalista ohjelmaa voi evaluoida kahdella tavalla, \textit{laiskasti} (lazy), ja \textit{tiukasti} (non-lazy, strict). Tiukassa mallissa kaikki lausekkeet evaluoidaan aina, oli se sitten tarpeellista tai ei.  Laiskassa mallissa lauseke evaluoidaan vasta tarvittaessa. Tämä mahdollistaa äärettömien tietorakenteiden luonnin. Laiska malli on myös tehokkaampi koska turhia argumentteja ei evaluoida. Funktionaalisista ohjelmointikielistä Haskell tukee laiskaa evaluaatiota ja Lisp tiukkaa evaluaatiota. Laiskaa evaluaatiota käyttävässä kielessä voidaan esimerkiksi käsitellä päättymättömiä tietorakenteita, ilman että nämä tietorakenteet veisivät äärettömästi tilaa.

Koska funktioilla ei ole sivuvaikutuksia, ne voidaan evaluoida missä järjestyksessä tahansa, ja kahden minkä tahansa funktion suoritus voidaan rinnakkaistaa huoletta. Näin funktionaalinen ohjelmointi tukee luonnostaan laskennan rinnakkaistamista monille prosessoriytimille.

Muistinhallinta on funktionaalisessa ohjelmoinnissa implisiittistä. Ohjelmoija ei koskaan varaa muistia, koska muuttujia ei ole. Näin funktionaalisiin ohjelmointikieliin sopii \textit{roskien keruu} luonnostaan. Itseasiassa Mccarthy lanseerasi roskien keruun Lispin yhteydessä.

% REKURSIO?
Lista on funktionaalisen ohjelmoinnin perustietorakenne, ja useimmissa funktionaalisissa kielissä se on osa kielen määrittelyä. Listoja käsitellään rekursiivisesti. Funktionaalisissa ohjelmointikielissä ei ole silmukoita ja suurten tietomäärien käsittely hoidetaan rekursion avulla.

\newpage
\thispagestyle{empty}


\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\end{document}
