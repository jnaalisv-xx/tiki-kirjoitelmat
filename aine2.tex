% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
%\doublespacing
%\singlespacing
\onehalfspacing

\title{Funktionaalinen ohjelmointi}
\author{Juho Naalisvaara}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
  D.1.1 [Programming Techniques]: Applicative (Functional) Programming, \\
  D.3.2 [Programming Languages]: Language Classifications - \\
  \textit{applicative languages;nonprocedural languages; 
	very high-level languages}, \\
  %D.3.3 [Programming Languages]: Language Constructs and Features, \\
  %F.1.1 [Computation by Abstract Devices]: Models of Computation, \\
  %F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages, \\
  F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic - \\ 
	\textit{lambda calculus and related systems}, \\
  K.2 [History of Computing]: Software
}}

\keywords{funktionaalinen ohjelmointi, korkeamman asteen funktiot, laiska evaluaatio}

\begin{abstract}

T‰m‰ kirjoitus esittelee funktionaalisen ohjelmointiparadigman.

\end{abstract}

\mytableofcontents




\section{Johdanto}
\textit{Funktionaalinen ohjelmointiparadigma} on ohjelmointitapa, jossa ohjelma rakennetaan funktioista, jotka palauttavat aina saman arvon samoilla argumenteilla. Puhtaassa funktionaalisessa ohjelmoinnissa ei ole tilaa, eik‰ siin‰ suoriteta per‰kk‰isi‰ k‰skyj‰ kuten proseduraalisessa- tai olio-ohjelmoinnissa. Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan sievent‰m‰ll‰ funktioita sis‰lt‰v‰‰ lauseketta \textit{Lambda-kalkyyliin} perustuvien sievennys‰‰ntˆjen mukaan. Sievennyss‰‰nnˆt mahdollistavat funktioiden v‰litt‰misen argumentteina, jolloin funktiot ovat niin sanottuja \textit{ensimm‰isen luokan olioita}. Funktiot jotka saavat argumentteinaan toisia funktioita, kutsutaan \textit{korkeamman asteen funktioiksi}. Niit‰ voidaan voidaan myˆs rakentaa ajonaikana ja palauttaa toisten funktioiden arvoina. Funktionaalisessa ohjelmoinnissa ei k‰ytet‰ silmukoita, vaan suuret tietom‰‰r‰t l‰pik‰yd‰‰n rekursion avulla.


proseduraalinen ohjelmointi on tilanmuuttamista,
funktionaalisessa lasketaan arvoja

\section{Historiaa}

\subsection{Lambda-kalkyyli}
%% Church m‰‰ritteli laskettavan funktion lambdan avulla?
Lambda-kalkyyli kehitettiin formalismiksi matemaattisten funktioiden m‰‰rittelyyn. Ilmaisuvoimaltaan se on yht‰l‰inen turingin koneiden kanssa \cite{lambda} s.5. Lambda-kalkyylissa funktioita ja niiden sovelluksia sis‰lt‰vi‰ lausekkeita sievennet‰‰n kunnes p‰‰st‰‰n normaalimuotoon, eli lauseketta ei voi en‰‰ sievent‰‰. T‰m‰ normaalimuoto on lambda-laskennan tulos. Lambda-kalkyyli on hyvin yksinkertainen mutta ilmaisuvoimainen sievennyss‰‰nnˆstˆ. Lambda-kalkyyli koostuu \textit{Lambda-lausekkeista} joita ovat \textit{abstraktio}, joka m‰‰rittelee funktion, \textit{sovellus}, joka on funktion sovellus argumenttiinsa, tai \textit{muuttuja}. Funktion vartalo on Lambda-lauseke, ja funktioilla on vain yksi argumentti. Mik‰li halutaan esimerkiksi kaksiargumenttinen funktio, voidaan m‰‰ritell‰ funktio joka palauttaa toisen funktion sitoen argumenttinsa palauttamansa funktion vartalossa.

%Lambda-lauseke voi olla \textit{abstraktio} eli funktiom‰‰ritelm‰, joka m‰‰rittelee funktion jolla on yksi argumentti ja vartalo joka on Lambda-lauseke, \textit{sovellus} joka on 

%Lambda-kalkyylissa funktiot esitet‰‰n \textit{lambda-abstraktioina} ja \textit{sovellus} mahdollistaa m‰‰riteltyjen funktioiden soveltamisen. \textit{Muuttujaan} voidaan sitoa mik‰ tahansa lambda-lauseke
% ja lambda-kalkyyli onkin sievennysj‰rjestelm‰ lambda-lausekkeille. Lambda-lauseke koostuu muuttujista, vakioista ja funktion sovelluksista. 

\subsection{Lisp}
Ensimm‰inen funktionaalinen ohjelmointikieli oli listojen k‰sittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1958 John McCarthy \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispiss‰ (kuten l‰hes kaikissa funktionaalisissa kieliss‰) on perustietorakenteena lista ja alkeisoperaattoreina funktiot jotka palauttavat listan ensimm‰isen solmun tai listan h‰nn‰n. McCarthy perusti kielens‰ Alonzo Churchin 1932 kehitt‰m‰‰n Lambda-kalkyyliin \cite{lambda} s.5.

\subsection{Lispist‰ nykyp‰iv‰‰n}
ML, Erlang,Scheme, Haskell, funktionaalisten ohjelmointikielten vaikutus muissa ohjelmointikieliss‰: Scala, Ruby, Python
% TODO: viite haskell raporttiin
%Haskell on alusta l‰htien suunniteltu puhtaaksi funktionaaliseksi ohjelmointikieleksi. 

%Muita funktionaaliseen ohjelmointiin sovelutuvia kieli‰ ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. N‰ist‰ ainoastaan Haskell on \textit{puhdas} funktionaalinen kieli. Muut kielet ovat joko multiparadigmakieli‰ tai mahdollistavat piirteit‰ jotka eiv‰t kuulu %%funktionaaliseen ohjelmointiin. Esimerkiksi Schemess‰ on \textit{Let-lause} jonka avulla voi m‰‰ritell‰ muuttujia. Erlang on %Ericsonin kehitt‰m‰ tosiaikaohjelmointiin soveltuva kieli. Scala on java-alustalla toimiva kieli



\section{Tarkempi m‰‰rittelykappale?}

\section{Funktionaalisen ohjelmoinnin erityispiirteit‰}

\subsection{Funktioista}
Korkeamman kertaluvun funktiot ja ensimm‰isen luokan funktiot

map, filter, foldr, foldl

\subsection{non strict semantics (laiska evaluaatio)}
Funktiot ja tietotyyppien konstruktorit eiv‰t evaluoi argumenttejaan ennen kuin niit‰ tarvitaan.

Funktionaalista ohjelmaa voi evaluoida kahdella tavalla, \textit{laiskasti} (lazy), ja \textit{tiukasti} (non-lazy, strict). Tiukassa mallissa kaikki lausekkeet evaluoidaan aina, oli se sitten tarpeellista tai ei.  Laiskassa mallissa lauseke evaluoidaan vasta tarvittaessa. Laiska malli on myˆs tehokkaampi koska turhia argumentteja ei evaluoida. Funktionaalisista ohjelmointikielist‰ Haskell tukee laiskaa evaluaatiota ja Lisp tiukkaa evaluaatiota. Laiskaa evaluaatiota k‰ytt‰v‰ss‰ kieless‰ voidaan esimerkiksi m‰‰ritell‰ p‰‰ttym‰ttˆmi‰ tietorakenteita, ilman ett‰ n‰m‰ tietorakenteet veisiv‰t ‰‰rettˆm‰sti tilaa.

\subsection{Sivuvaikutuksettomuus}
Koska funktioilla ei ole sivuvaikutuksia, ne voidaan evaluoida miss‰ j‰rjestyksess‰ tahansa, ja kahden mink‰ tahansa funktion suoritus voidaan rinnakkaistaa huoletta. N‰in funktionaalinen ohjelmointi tukee luonnostaan laskennan rinnakkaistamista monille prosessoriytimille.

\subsection{tyypitus, tiedon abstrahointi ja algebralliset tietotyypit}
algebrallinen tietotyyppi on tietotyyppi jonka jokainen arvo
on jonkin toisen tietotyypin arvo k‰‰rittyn‰ yhteen 
algebrallisen tietotyypin konstruktoreista. ADT:n
 konstruktoria ei koskaan suoriteta ja ainoa tapa p‰‰st‰ 
k‰siksi tietoon on "kuoria" konstruktori pattern matchingin 
avulla

\subsection{Rekursio}
Puhtaissa funktionaalisissa ohjelmointikieliss‰ ei ole silmukoita, vaan suurten tietom‰‰rien k‰sittely hoidetaan rekursiolla. Lista on funktionaalisen ohjelmoinnin perustietorakenne, ja useimmissa funktionaalisissa kieliss‰ se on osa kielen m‰‰rittely‰. Listoja k‰sitell‰‰n rekursiivisesti. 


\subsection{yht‰lˆt ja pattern matchi}

\subsection{persistentit tietorakenteet}
vai laitetaanko esimerkiksi esittelyyn lyhyesti

\subsection{muodollinen semantiikka (formal semantics)}

\subsection{Roskienkeruu}
Muistinhallinta on funktionaalisessa ohjelmoinnissa implisiittist‰. Ohjelmoija ei koskaan varaa muistia, koska muuttujia ei ole. N‰in funktionaalisiin ohjelmointikieliin sopii \textit{roskien keruu} luonnostaan. Itseasiassa McCarthy lanseerasi roskien keruun Lispin yhteydess‰ \cite{lisp} s.27.

\subsection{Lyhyt haskell esittely?}
vai kaikissa kappaleissa haskell esimerkkej‰?



%\begin{itemize}
%\item l‰hdeviitteen tulee aina olla niin tarkka, ett‰
%l‰hde on sen perusteella tunnistettavissa ja lˆydett‰viss‰ luetteloista
%ja kirjastoista,
%\item erityyppisten l‰hteiden (kirjat, konferenssit, lehdet) on erotuttava
%toisistaan
%ja
%\item luettelon eri osien tulee olla mahdollisimman
%yhdenmukaisia, erityisesti l‰hdetyypin sis‰ll‰.
%\end{itemize}





%\begin{figure}[h]
%%\begin{figure}[tbh] t= top, b = bottom, h=here
%\ \newline
%\begin{center}
%\includegraphics[width=0.9\textwidth]{kuvaesimerkki.pdf}
%%\rotatebox{90}{\includegraphics[scale=.75]{kuvaesimerkki.pdf}}
%\caption{Kuvan elementit.}
%\label{kuvaesimerkki}
%\end{center}
%\end{figure}









%
% Sitten alkaa l‰hdeluettelo
%


\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

%Liitteet ovat t‰ss‰ vain sis‰llysluettelon ja esitystavan mallina.
%Jokainen liite aloitetaan yleens‰ uudelta sivulta, jonka alkuun tulee
%liitteen numero ja nimi. Kunkin liitteen sivut numeroidaan erikseen.


\end{document}
