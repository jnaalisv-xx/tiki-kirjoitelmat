% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
\onehalfspacing

\title{Funktionaalinen ohjelmointi}
\author{Juho Naalisvaara}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
  D.1.1 [Programming Techniques]: Applicative (Functional) Programming, \\
  D.3.2 [Programming Languages]: Language Classifications - \\
  \textit{applicative languages;nonprocedural languages; 
	very high-level languages}, \\
  F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic - \\ 
	\textit{lambda calculus and related systems}, \\
  K.2 [History of Computing]: Software
}}

\keywords{funktionaalinen ohjelmointi, korkeamman asteen funktiot, laiska evaluaatio}

\begin{abstract}

T‰m‰ kirjoitus esittelee funktionaalisen ohjelmointiparadigman.

\end{abstract}

\mytableofcontents

\section{Johdanto}
%% WANHAA KAMAA
\textit{Funktionaalinen ohjelmointiparadigma} on ohjelmointitapa, jossa ohjelma rakennetaan funktioista, jotka palauttavat aina saman arvon samoilla argumenteilla. Puhtaassa funktionaalisessa ohjelmoinnissa ei ole tilaa, eik‰ siin‰ suoriteta per‰kk‰isi‰ k‰skyj‰ kuten proseduraalisessa- tai olio-ohjelmoinnissa. Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan sievent‰m‰ll‰ funktioita sis‰lt‰v‰‰ lauseketta \textit{lambda-kalkyyliin} perustuvien sievennys‰‰ntˆjen mukaan. Sievennyss‰‰nnˆt mahdollistavat funktioiden v‰litt‰misen argumentteina, jolloin funktiot ovat niin sanottuja \textit{ensimm‰isen luokan olioita}. Funktiot jotka saavat argumentteinaan toisia funktioita, kutsutaan \textit{korkeamman asteen funktioiksi}. Niit‰ voidaan voidaan myˆs rakentaa ajonaikana ja palauttaa toisten funktioiden arvoina. Funktionaalisessa ohjelmoinnissa ei k‰ytet‰ silmukoita, vaan suuret tietom‰‰r‰t l‰pik‰yd‰‰n rekursion avulla.
%% /WANHAA KAMAA

%%Ohjelmointi ilman sivuvaikutuksia, ohjelmointi funktioarvoilla. Imperatiivisessa ohjelmoinnissa ohjelmalla on tila, joka %%%%koostuu muuttujien arvoista ja olioiden kenttien arvoista. Ohjelmassa suoritetaan lausekkeita jotka muuttavat ohjelman tilaa.

\section{Historiaa}
%% WANHAA KAMAA
\subsection{Lambda-kalkyyli}
Lambda-kalkyyli kehitettiin formalismiksi matemaattisten funktioiden m‰‰rittelyyn. Ilmaisuvoimaltaan se on yht‰l‰inen turingin koneiden kanssa \cite{lambda} s.5. Lambda-kalkyylissa funktioita ja niiden sovelluksia sis‰lt‰vi‰ lausekkeita sievennet‰‰n kunnes p‰‰st‰‰n normaalimuotoon, eli lauseketta ei voi en‰‰ sievent‰‰. T‰m‰ normaalimuoto on lambda-laskennan tulos. Lambda-kalkyyli on hyvin yksinkertainen mutta ilmaisuvoimainen sievennyss‰‰nnˆstˆ. Lambda-kalkyyli koostuu \textit{lambda-lausekkeista} joita ovat \textit{abstraktio}, joka m‰‰rittelee funktion, \textit{sovellus}, joka on funktion sovellus argumenttiinsa, tai \textit{muuttuja}. Funktion vartalo on lambda-lauseke, ja funktioilla on vain yksi argumentti. Mik‰li halutaan esimerkiksi kaksiargumenttinen funktio, voidaan m‰‰ritell‰ funktio joka palauttaa toisen funktion sitoen argumenttinsa palauttamansa funktion vartalossa.

\subsection{Lisp}
Ensimm‰inen funktionaalinen ohjelmointikieli oli listojen k‰sittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1958 John McCarthy \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispiss‰ (kuten l‰hes kaikissa funktionaalisissa kieliss‰) on perustietorakenteena lista ja alkeisoperaattoreina funktiot jotka palauttavat listan ensimm‰isen solmun tai listan h‰nn‰n. McCarthy perusti kielens‰ Alonzo Churchin 1932 kehitt‰m‰‰n lambda-kalkyyliin \cite[s.5]{lambda} 

%Lambda-lauseke voi olla \textit{abstraktio} eli funktiom‰‰ritelm‰, joka m‰‰rittelee funktion jolla on yksi argumentti ja vartalo joka on Lambda-lauseke, \textit{sovellus} joka on 

%Lambda-kalkyylissa funiidennktiot esitet‰‰n \textit{lambda-abstraktioina} ja \textit{sovellus} mahdollistaa m‰‰riteltyjen funktioiden soveltamisen. \textit{Muuttujaan} voidaan sitoa mik‰ tahansa lambda-lauseke
% ja lambda-kalkyyli onkin sievennysj‰rjestelm‰ lambda-lausekkeille. Lambda-lauseke koostuu muuttujista, vakioista ja funktion sovelluksista. 

\subsection{Lispist‰ nykyp‰iv‰‰n}
Muita funktionaaliseen ohjelmointiin sovelutuvia kieli‰ ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. N‰ist‰ ainoastaan Haskell on \textit{puhdas} funktionaalinen kieli. Muut kielet ovat joko multiparadigmakieli‰ tai mahdollistavat piirteit‰ jotka eiv‰t kuulu funktionaaliseen ohjelmointiin. Esimerkiksi Schemess‰ on \textit{let-lause} jonka avulla voi m‰‰ritell‰ muuttujia. Erlang on Ericsonin kehitt‰m‰ tosiaikaohjelmointiin soveltuva kieli. Scala on java-alustalla toimiva kieli

%% /WANHAA KAMAA

%% TODO: imperatiivinen vs proseduraalinen vs algoritminen
%% vs olio-ohjelmointi, termit yhdenmukaisiksi!!!
%% \section{Lyhyt Haskell-johdanto}
%% Joitakin esimerkkej‰ on esitetty Haskell-kielell‰. T‰ss‰ lyhyt johdanto jonka perusteella esimerkit voi ymm‰rt‰‰ vaikkei kielt‰ tuntisikaan aikaisemmin.
%% Haskell-ohjelmoijan perustyˆkalu on funktio. Funktion m‰‰ritell‰‰n n‰in: funktio parametri = laskennan tulos
%% Tietotyypit. data, tyyppi-konstruktorit, konstruktorit, omien tyyppien rakentaminen

\section{Funktionaalisen ohjelmoinnin erityispiirteit‰}
T‰ss‰ kappaleessa esitell‰‰n funktionaalisen ohjelmointityylin k‰sitteit‰ ja ominaisuuksia. 

\subsection{Puhtaat funktiot ja sivuvaikutuksettomuus}
Funktiolla sanotaan olevan \textit{sivuvaikutuksia} (engl. \textit{side effects}) jos se muuttaa ohjelman tilaa (engl. \textit{state}) tai vaikuttaa ulkomaailmaan muuten kuin paluuarvonsa kautta. Ohjelman tila on sen paikallisten ja globaalien muuttujien arvo tiettyn‰ hetken‰, ja kaikki ohjelmointi miss‰ muutetaan kyseisten muuttujien arvoa on sivuvaikutuksellista ohjelmointia. Imperatiivinen ohjelmointityyli perustuu nimenomaan ohjelman tilan muuttamiseen.
%% TODO: l‰hde! 

\textit{Puhtaat funktiot} (engl. \textit{pure functions}) ovat funktioita matemaattisessa merkityksess‰. Ohjelmoinnista puhuttaessa saatetaan funktioiksi kutsua jopa aliohjelmia joiden laskennan tulos riippuu jostain globaalista muuttujasta, jolloin saattaa p‰te‰ \textit{f(x) $\ne$ f(x)} eri kutsuhetkin‰. Matemaattisilla funktioilla ei ole tilaa, eik‰ sivuvaikutuksia. Matemaattiset funktiot ovat kuvauksia l‰htˆjoukosta (parametrit) maalijoukkoon (paluuarvo), ja ne palauttavat samoilla parametreilla aina saman paluuarvon. 

Funktionaalinesessa ohjelmoinnissa ohjelma koostetaan puhtaista funktiosta, joilla ei siis ole tilaa eik‰ sivuvaikutuksia. N‰in funktionaalinen ohjelmointi on tila- ja sivuvaikutuksetonta. Jotkin kielet, kuten Lisp ja sen johdannaiset, sallivat sivuvaikutukset joten ne eiv‰t ole puhtaita funktionaalisia kieli‰, vaan pikemminkin hybridikieli‰ joissa on tuki funktionaaliselle ohjelmoinnille. Tilattomuudesta seuraa ett‰ muuttujien arvoja ei voi muuttaa niiden luonnin j‰lkeen. 
%% TODO: Scheme tarjoaa let-lauseen??? SICP
%% TODO: sivuvaikutusten sallimisille
%% TODO: t‰ss‰ kirjoitelmassa muuttuja ei ole kuin imperatiivisessa

Sivuvaikutuksettomuudella on sek‰ myˆnteisi‰ ett‰ kielteisi‰ seurauksia. Koska funktionaalisessa ohjelmoinnissa ei muokata tilaa, ei myˆsk‰‰n tietorakenteita pysty muokkaamaan niiden luonnin j‰lkeen, vaan esimerkiksi poistettaessa listasta alkio, luodaan uusi lista vanhan listan kopiona ilman poistettavaa alkiota. Suuria tietorakenteita kuten tietokantoja ei voida toteuttaa ilman sivuvaikutuksia tehokkaasti. Jos esimerkiksi halutaan muuttaa yhden rivin yhden sarakkeen arvo tietokannassa jossa on miljoonia rivej‰, tulisi muutoksen tekev‰n funktion palauttaa kokonaan uusi tietokanta. Lis‰ksi siirr‰nt‰, syˆttˆ ja tulostus, on luonteeltaan sivuvaikutuksellista. Siirr‰nt‰‰n tosin on kehitetty elegantteja funktionaalisia ratkaisuja. 
%%(TODO: l‰hde, haskelin stream ja monad io),tietorakenteista, optimoiva k‰‰nt‰j‰?P

Sivuvaikutuksettomuudesta kuitenkin seuraa ett‰ funktioiden suoritus voidaan huoletta rinnakkaistaa ja ohjelmien tuotantokustannukset laskevat koska ohjelmia on helpompi laatia, korjata ja yll‰pit‰‰\cite[s.527]{scott}.
%TODO: jotain muuta sivuvaikutuksettomuudesta? Tietorakenteen ja sivuvaikutukset? Funktionaaliset tietorakenteet? sivuvaikutusten parempi m‰‰ritelm‰

\subsection{Funktiot ensimm‰isen luokan arvoina}
\textit{Ensimm‰isen luokan arvo} (engl.\textit{first class value}) voidaan v‰litt‰‰ parametrina, palauttaa funktion paluuarvona tai luoda suoritusaikana \cite[s.526]{scott}. Funktionaalisessa ohjelmoinnissa siis funktioilla voi tehd‰ kaikkea t‰t‰. Proseduraalisessa (imperatiivisessa?, algoritmisessa?) ohjelmoinnissa funktiot ovat yleens‰ toisen luokan arvoja, niit‰ ei voi v‰litt‰‰ parametreina, palauttaa paluuarvoina tai luoda suoritusaikana. Jotkut imperatiiviset kielet kuten C tukevat funktio-osoittimien v‰litt‰mist‰ parametreina, funktioita ei C:ss‰ kuitenkaan voi luoda suoritusaikana jolloin ne eiv‰t ole ensimm‰isen luokan arvoja. Oliokielist‰ SmallTalk tukee funktioita ensimm‰isen luokan arvoina. Yleisesti k‰ytˆss‰ olevissa kieliss‰ primitiivit kuten kokonaisluvut, liukuluvut, merkit, merkkijonot ja oliot ovat ensimm‰isen luokan arvoja. 

Koska ensimm‰isen luokan arvoja voi luoda ohjelmalohkojen sis‰ll‰, voidaan m‰‰ritell‰ funktio jonka m‰‰rittelyss‰ k‰ytet‰‰n sen m‰‰rittelylohkossa n‰kyvi‰ muuttujia. Funktio voidaan edelleen v‰litt‰‰ parametrina toiselle funktiolle jolloin funktion k‰ytt‰m‰t muuttujat ovat n‰kyvyysalueensa ulkopuolella, ja niit‰ ei voi vapauttaa muistinhallinnan toimesta kun funktion m‰‰rittelylohkon k‰ytt‰m‰ muisti vapautetaan. Funktiota jonka m‰‰rittelyss‰ n‰in k‰ytet‰‰n m‰‰rittelylohkonsa muuttujia, kutsutaan \textit{sulkeumaksi} (engl. \textit{closure}).
%% Sulkeumilla voidaan toteuttaa tila?

\subsection{Korkeamman kertaluvun funktiot}
\textit{Korkeamman kertaluvun funktioiksi} (engl. \textit{higher order functions, functional forms}) kutsutaan funktioita jotka ottavat parametrinaan toisen funktion, tai palauttavat paluuarvonaan funktion\cite[s.546]{scott}. Yksi yleisimpi‰ tapoja k‰ytt‰‰ korkeamman kertaluvun funktioita on rakentaa niiden avulla uusia funktioita. Esimerkiksi Haskelin \textit{map}-funktio ottaa parametrinaan funktion ja listan, ja k‰y listan rekursiivisesti l‰pi soveltaen parametrinaan saamaa funktioita jokaiselle listan alkiolle. 

\subsection{Rekursio}
Koska ohjelmasilmukoiden toiminta riippuu ohjelman tilasta, toisin sanoen jonkin muuttujan arvosta, ei sivuvaikutuksettomassa ohjelmoinnissa voida k‰ytt‰‰ perinteisi‰ silmukoita toiston aikaansaamiseen. Funktionaalisessa ohjelmoinnissa toisto aikaansaadaan rekursiolla. Listat ovat funktionaalisissa kieliss‰ t‰rkeit‰ koska niill‰ on luonnollinen rekursiivinen m‰‰ritelm‰. Lista voidaan m‰‰ritell‰ parina, jonka ensimm‰inen alkio on listan ensimm‰inen alkio, jolloin parin toinen alkio on listan loppuosa. Listan loppuosa on lista, tai tyhj‰ arvo. Listoille on funktionaalisissa kieliss‰ usein valmiiksi m‰‰riteltyj‰ alkeisoperaatioita kuten \textit{head} joka palauttaa parametrina annetun listan ensimm‰isen alkion, tai \textit{tail}, joka palauttaa paramatrina annetun listan ilman ensimm‰ist‰ alkiotaan.
%% TODO: esimerkki
%%\begin{displaymath}
%%Lista a = Pair a (Lista a)
%%        | Nil
%%\end{displaymath} 
 
%% TODO: mit‰ on laiska evaluaatio Suomeksi?
%% referential transparency
\subsection{Laiska evaluaatio}
\textit{Laiska evaluatio} (engl. \textit{lazy evaluation, non-strict evaluation}) tarkoittaa blah blah \textit{laiska funktio} blah blah

\subsection{Yht‰lˆt ja hahmontunnistus}

\subsection{Tyypitys, monimuotoisuus ja tiedon abstrahointi}
%% Tyypitys, monimuotoisuus Tiedon abstrahointi, 
%\textit{Vahva staattinen tyypitys} (engl. \textit{strong static typing}) blah blah
%\textit{Tyyppien johtaminen} (engl. \textit{type inference})

\textit{Monimuotoisuus} (engl. \textit{polymorphism}) on funktionaalisissa kieliss‰ t‰rke‰ ominaisuus, koska se sallii funktioiden k‰ytˆn mahdollisimman monentyyppisill‰ parametreilla. Lisp ja sen johdannaiset ovat dynaamisesti tyypitettyj‰, ja siten luonnostaan monimuotoisia. Haskell saavuttaa monimuotoisuuden tyyppien johtamisen kautta.

\subsection{Funktionaalinen siirr‰nt‰}
Haskell IO monadi, kuvaus.

\section{Yhteenveto}
Funktionaalinen ohjelmointi on kehittynyt matemaattisesta formalismista varteenotettavaksi ohjelmointiparadigmaksi vastaamaan modernin ohjelmistokehityksen haasteisiin. Funktionaalinen paradigma tarjoaa voimakkaat tyˆkalut abstraktioiden rakentamiseen. 
%% TODO: lis‰‰

\newpage

%%\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

\end{document}
