
% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage{ae,aecompl}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{graphicx}

% juhon paketti
\usepackage{verbatim}

\begin{document}
\title{Funktionaalinen ohjelmointi}
\author{Juho Naalisvaara}
\date{\today}
\level{Tieteellisen kirjoittamisen kurssin aine}
\maketitle

\onehalfspacing

\level{Tutkielma}
\faculty{Matemaattis-luonnontieteellinen}
\department{Tietojenk‰sittelytieteen laitos}
\subject{Tietojenk‰sittelytiede}
\numberofpagesinformation{\numberofpages\ sivua}
\classification{ \\
  D.1.1 [Programming Techniques]: Applicative (Functional) Programming, \\
  D.3.2 [Programming Languages]: Language Classifications, \\
  D.3.3 [Programming Languages]: Language Constructs and Features, \\
  F.1.1 [Computation by Abstract Devices]: Models of Computation, \\
  F.3.2 [Logics and Meanings of Programs]: Semantics of Programming Languages, \\
  F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic
}
\keywords{esimerkki}

\begin{abstract}
    Johdatus funktionaaliseen ohjelmointiin, Lambda-kalkyyli, Lisp, funktiot arvoina.
\end{abstract}

\mytableofcontents


% Funktionaalinen ohjelmointi on lausekkeiden sievennyst‰
%% TODO: eka lause!!!
\section{Johdanto}
\textit{Funktionaalinen ohjelmointiparadigma} on ohjelmointitapa, jossa ohjelma rakennetaan funktioista, jotka palauttavat aina saman arvon samoilla argumenteilla. Puhtaassa funktionaalisessa ohjelmoinnissa ei ole tilaa, eik‰ siin‰ suoriteta per‰kk‰isi‰ k‰skyj‰ kuten proseduraalisessa- tai olio-ohjelmoinnissa. Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan sievent‰m‰ll‰ funktioita sis‰lt‰v‰‰ lauseketta \textit{Lambda-kalkyyliin} perustuvien sievennys‰‰ntˆjen mukaan. Sievennyss‰‰nnˆt mahdollistavat funktioiden v‰litt‰misen argumentteina, jolloin funktiot ovat niin sanottuja \textit{ensimm‰isen luokan olioita}. Funktiot jotka saavat argumentteinaan toisia funktioita, kutsutaan \textit{korkeamman asteen funktioiksi}. Niit‰ voidaan voidaan myˆs rakentaa ajonaikana ja palauttaa toisten funktioiden arvoina. Funktionaalisessa ohjelmoinnissa ei k‰ytet‰ silmukoita, vaan suuret tietom‰‰r‰t l‰pik‰yd‰‰n rekursion avulla.

\section{Historiaa ja Lisp}
Ensimm‰inen funktionaalinen ohjelmointikieli oli listojen k‰sittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1958 John McCarthy \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispiss‰ (kuten l‰hes kaikissa funktionaalisissa kieliss‰) on perustietorakenteena lista ja alkeisoperaattoreina funktiot jotka palauttavat listan ensimm‰isen solmun tai listan h‰nn‰n. McCarthy perusti kielens‰ Alonzo Churchin 1932 kehitt‰m‰‰n \textit{Lambda-kalkyyliin} \cite{lambda} s.5.

\section{Lambda-kalkyyli}
%% Church m‰‰ritteli laskettavan funktion lambdan avulla?
Lambda-kalkyyli kehitettiin formalismiksi matemaattisten funktioiden m‰‰rittelyyn. Ilmaisuvoimaltaan se on yht‰l‰inen turingin koneiden kanssa \cite{lambda} s.5. Lambda-kalkyylissa funktioita ja niiden sovelluksia sis‰lt‰vi‰ lausekkeita sievennet‰‰n kunnes p‰‰st‰‰n normaalimuotoon, eli lauseketta ei voi en‰‰ sievent‰‰. T‰m‰ normaalimuoto on lambda-laskennan tulos. Lambda-kalkyyli on hyvin yksinkertainen mutta ilmaisuvoimainen sievennyss‰‰nnˆstˆ. Lambda-kalkyyli koostuu \textit{Lambda-lausekkeista} joita ovat \textit{abstraktio}, joka m‰‰rittelee funktion, \textit{sovellus}, joka on funktion sovellus argumenttiinsa, tai \textit{muuttuja}. Funktion vartalo on Lambda-lauseke, ja funktioilla on vain yksi argumentti. Mik‰li halutaan esimerkiksi kaksiargumenttinen funktio, voidaan m‰‰ritell‰ funktio joka palauttaa toisen funktion sitoen argumenttinsa palauttamansa funktion vartalossa.


%Lambda-lauseke voi olla \textit{abstraktio} eli funktiom‰‰ritelm‰, joka m‰‰rittelee funktion jolla on yksi argumentti ja vartalo joka on Lambda-lauseke, \textit{sovellus} joka on 

%Lambda-kalkyylissa funktiot esitet‰‰n \textit{lambda-abstraktioina} ja \textit{sovellus} mahdollistaa m‰‰riteltyjen funktioiden soveltamisen. \textit{Muuttujaan} voidaan sitoa mik‰ tahansa lambda-lauseke
% ja lambda-kalkyyli onkin sievennysj‰rjestelm‰ lambda-lausekkeille. Lambda-lauseke koostuu muuttujista, vakioista ja funktion sovelluksista. 

\section{Muita funktionaalisia kieli‰}
Muita funktionaaliseen ohjelmointiin sovelutuvia kieli‰ ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. N‰ist‰ ainoastaan Haskell on \textit{puhdas} funktionaalinen kieli. Muut kielet ovat joko multiparadigmakieli‰ tai mahdollistavat piirteit‰ jotka eiv‰t kuulu funktionaaliseen ohjelmointiin. Esimerkiksi Schemess‰ on \textit{Let-lause} jonka avulla voi m‰‰ritell‰ muuttujia. Erlang on Ericsonin kehitt‰m‰ tosiaikaohjelmointiin soveltuva kieli. Scala on java-alustalla toimiva kieli

% TODO: viite haskell raporttiin
%Haskell on alusta l‰htien suunniteltu puhtaaksi funktionaaliseksi ohjelmointikieleksi. 

\section{Funktionaalisen ohjelmoinnin erityispiirteit‰}
Funktionaalista ohjelmaa voi evaluoida kahdella tavalla, \textit{laiskasti} (lazy), ja \textit{tiukasti} (non-lazy, strict). Tiukassa mallissa kaikki lausekkeet evaluoidaan aina, oli se sitten tarpeellista tai ei.  Laiskassa mallissa lauseke evaluoidaan vasta tarvittaessa. Laiska malli on myˆs tehokkaampi koska turhia argumentteja ei evaluoida. Funktionaalisista ohjelmointikielist‰ Haskell tukee laiskaa evaluaatiota ja Lisp tiukkaa evaluaatiota. Laiskaa evaluaatiota k‰ytt‰v‰ss‰ kieless‰ voidaan esimerkiksi m‰‰ritell‰ p‰‰ttym‰ttˆmi‰ tietorakenteita, ilman ett‰ n‰m‰ tietorakenteet veisiv‰t ‰‰rettˆm‰sti tilaa.

\subsection{Sivuvaikutukset}
Koska funktioilla ei ole sivuvaikutuksia, ne voidaan evaluoida miss‰ j‰rjestyksess‰ tahansa, ja kahden mink‰ tahansa funktion suoritus voidaan rinnakkaistaa huoletta. N‰in funktionaalinen ohjelmointi tukee luonnostaan laskennan rinnakkaistamista monille prosessoriytimille.

\subsection{Muistinhallinta}
Muistinhallinta on funktionaalisessa ohjelmoinnissa implisiittist‰. Ohjelmoija ei koskaan varaa muistia, koska muuttujia ei ole. N‰in funktionaalisiin ohjelmointikieliin sopii \textit{roskien keruu} luonnostaan. Itseasiassa McCarthy lanseerasi roskien keruun Lispin yhteydess‰ \cite{lisp} s.27.

\subsection{Rekursio}
Puhtaissa funktionaalisissa ohjelmointikieliss‰ ei ole silmukoita, vaan suurten tietom‰‰rien k‰sittely hoidetaan rekursiolla. Lista on funktionaalisen ohjelmoinnin perustietorakenne, ja useimmissa funktionaalisissa kieliss‰ se on osa kielen m‰‰rittely‰. Listoja k‰sitell‰‰n rekursiivisesti. 

\newpage
\thispagestyle{empty}


\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\end{document}
