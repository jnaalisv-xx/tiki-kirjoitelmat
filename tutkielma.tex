% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
\onehalfspacing

\title{Funktionaalinen ohjelmointi}
\author{Juho Naalisvaara}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
  D.1.1 [Programming Techniques]: Applicative (Functional) Programming, \\
  D.3.2 [Programming Languages]: Language Classifications - \\
  \textit{applicative languages;nonprocedural languages; 
	very high-level languages}, \\
  F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic - \\ 
	\textit{lambda calculus and related systems}, \\
  K.2 [History of Computing]: Software
}}

\keywords{funktionaalinen ohjelmointi, korkeamman asteen funktiot, laiska evaluaatio}

\begin{abstract}
Funktionaalinen ohjelmointiparadigma tarjoaa laskennan mallin, joka pohjatuu funktioiden matemaattiseen määritelmään. Funktionaalinen ohjelmointi on tilatonta. Kaikki yleisesti käytössä olevat kielet ovat imperatiivisia. Imperatiivisessa ohjelmoinnissa laskenta tapahtuu muuttamalla ohjelman tilaa. Haskell on yleiskäyttöinen funktionaaliseen ohjelmointiin suunniteltu moderni ohjelmointikieli. Funktionaalinen ohjelmointi eroaa usealla tapaa imperatiivisesta ohjelmoinnista. Laskenta mallinnetaan funktioina, funktio on keskeinen abstrahointityökalu, sekä listoja ja rekursiota käytetään runsaasti.
\end{abstract}

\mytableofcontents

\section{Johdanto}

Yleisimmät käytössä olevat ohjelmointikielet perustuvat laskennan malliin, jossa ohjelmalla on \textit{tila} (state). Tilaa muokataan ohjelmointikielen tarjoamien lauseiden tai komentojen avulla. Tällaisia ohjelmointikieliä, kuten Java tai C\#, kutsutaan \textit{imperatiivisiksi} (imperative language). Imperatiivisessa ohjelmoinnissa ohjelmoija kirjoittaa lauseita, jotka muokkaavat ohjelman tilaa tietyssä järjestyksessä. Imperatiivisen ohjelmointiparadigman laskennan mallia kutsutaan \textit{Turingin koneeksi} (Turing machine) kehittäjänsä Alan Turingin mukaan. Imperatiivisen mallin ongelmana voidaan pitää sitä, että ohjelman oikeaksi todistaminen on hyvin hankalaa. Samoin ohjelman kaikkien mahdollisten suorituspolkujen testaaminen on yleensä mahdotonta ohjelman eri tilojen lukumäärän vuoksi.

\textit{Funktionaalinen ohjelmointiparadigma} (functional programming) vastaa näihin haasteisiin tarjoamalla ohjelmointimallin, jossa ohjelmilla ei ole tilaa. Tilattomuus helpottaa ohjelman testaamista huomattavasti, koska se vähentää mahdollisten suorituspolkujen määrää. Tilattomuudesta seuraa myös että funktionaalisten ohjelmien oikeaksi todistaminen on myös huomattavasti helpompaa kuin imperatiivisten. Lisäksi funktionaaliset ohjelmat ovat yleensä lyhyempiä kuin niiden imperatiiviset vastineensa, koska funktionaaliset kielet ovat yleensä ilmaisuvoimaisempia kieliä kuin imperatiiviset.

Funktionaalisen ohjelmoinnin laskennan mallina on funktio, sen matemaattisessa merkityksessä. Matemaattisilla funktioilla ei ole tilaa eikä \textit{sivuvaikutuksia} (side-effects), vaan ne ovat kuvauksia lähtöjoukosta (domain) maalijoukkoon (range). Usein myös imperatiivisen ohjelmoinnin yhteydessä puhutaan funktioista, esimerkiksi C-kielessä kaikki suoritettava koodi on \"funktioissa\". Nämä C-kielen funktiot eivät kuitenkaan ole funktioita matemaattisessa merkityksessä, sillä niillä voi olla sisäinen tila ja ne voivat vaikuttaa funktion ulkoiseen tilaan, esimerkiksi muuttamalla jonkin globaalin muuttujan arvoa. Toisaalta C-kielen funktion laskennan tulos voi myös riippua ohjelman tilasta, jolloin funktio ei laske samoilla argumenteilla samaa tulosta joka kutsukerralla.

Funktionaalisen paradigman lähtökohtana on koostaa ohjelma lukuisista pienistä, helposti testattavista funktioista. Funktioita voi myös välittää parametreina tai palauttaa paluuarvoina. Funktionaaliselle ohjelmoinnille tyypillistä on runsas listojen ja rekursion käyttö. Rekursiivisesti määritelty lista onkin useimmissa funktionaalisissa kielissä perustietotyyppi. Koska funktionaalisessa ohjelmoinnissa ei ole tilaa, ei myöskään tilaan perustuvia toistorakenteita, kuten for-lausetta, voi käyttää. Toisto saadaankin aikaan rekursiolla.

Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan evaluoimalla eli sieventämällä lausekkeita. Lauseke voi olla arvo, funktio tai funktion sovellus argumenttiinsa. Argumentit ovat lausekkeita, eli arvoja, funktioita tai funktioiden sovelluksia argumentteihinsa. Lausekkeen evaluoinnissa arvot ja funktiot ovat jo normaalimuodossaan, eivätkä enää sievenny yksinkertaisempaan muotoon. Evaluoitaessa funktion sovellusta argumenttiinsa, funktion formaalit parametrit korvataan argumenteilla. Jos tuloksena saatu lauseke on normaalimuotoinen, evaluointi päättyy. Muutoin tuloslauseketta sievennetään, kunnes päästään lausekkeen normaalimuotoon, jota ei voi enää sieventää. Tämä normaalimuoto on laskennan tulos.

Funktionaalisen ohjelmoinnin laskennan malli on otettu Alonzo Churchin vuonna 1936 kehittämästä \textit{lambda-laskennasta} (lambda-calculus). Vuonna 1960 esiteltiin ensimmäinen funktionaaliseen ohjelmointiin soveltuva kieli, Lisp (LISt Processing Language) \cite{lisp}. Kielen kehittäjä, John McCarthy, halusi kieleensä mahdollisuuden välittää funktioita argumentteina, ja lambda-kalkyyli tarjosi tähän sopivan notaation. 

Lispin johdannaiset, Scheme ja Common Lisp, ovat edelleen käytössä. Muita funktionaaliseen ohjelmointiin soveltuvia kieliä ovat muun muassa, Scala, F\#, Standard ML, Erlang ja Python. Edellämainitut kielet eivät kuitenkaan ole puhtaasti funktionaalisia: joko ne sallivat sivuvaikutukset tai ovat moniparadigmakieliä. Vuonna 1987 päivänvalon nähnyt Haskell \cite[s.1]{gentle} on sivuvaikutukseton alun alkaen funktionaaliseen ohjelmointiin suunniteltu kieli. 

\newpage
\section{Historiaa}
Funktionaalinen ohjelmointiparadigma on lähes yhtä vanha kuin tietokoneet, ja sen teoreettinen pohja luotiin ennenkuin ensimmäinen elektroninen tietokone oli nähnyt päivänvalon. Tässä kappaleessa kerrotaan lyhyesti lambda-laskennasta, johon funktionaalisen ohjelmoinnin malli pohjautuu, ensimmäisestä funktionaaliseen ohjelmointiin soveltuvasta ohjelmointikielestä sekä lopuksi mainitaan muutamia suosituimpia nykyisin käytössä olevia funktionaalisia kieliä.

\subsection{Lambda-laskenta}
Lambda-laskenta kehitettiin matemaattiseksi formalismiksi, jolla pystyi määrittelemään kaikki laskettavissa olevat funktiot. Tarkoituksena oli selvittää, voidaanko määritellä algoritmi, jolla laskea kaikki laskettavissa olevat funktiot. Ongelmaa kutsuttiin nimellä \textit{pysähtymisongelma} (saks. \textit{entscheidungsproblem}). Church kuitenkin osoitti sen olevan mahdotonta. Samanaikaisesti Alan Turing kehitti mukaansa nimetyn \textit{turing-koneen} (Turing machine), joka myös määritteli joukon funktioita. Turing todisti, että hänen mallinsa oli ilmaisuvoimaltaan yhtä voimakas kuin Churchin lambda-laskenta, eli se määritteli lambda-laskennan tavoin kaikki laskettavissa olevat funktiot \cite[s.5]{lambda}. 

Lambda-laskennassa on yksi sievennyssääntö, jonka mukaan funktion formaali parametri korvataan sille annetulla argumentilla funktion vartalossa. Funktioita ja niiden sovelluksia sisältäviä lausekkeita sievennetään kunnes päästään normaalimuotoon, eli lauseketta ei voi enää sieventää. Tämä normaalimuoto on lambda-laskennan tulos. Lambda-laskenta on hyvin yksinkertainen, mutta ilmaisuvoimainen sievennyssäännöstö. Lambda-laskenta koostuu \textit{lambda-lausekkeista}, joita ovat \textit{abstraktio} (function abstraction), joka määrittelee funktion, \textit{sovellus} (application), joka on funktion sovellus argumenttiinsa, tai \textit{muuttuja} (variable). Funktion vartalo on lambda-lauseke, ja funktioilla on vain yksi argumentti. Mikäli halutaan esimerkiksi kaksiargumenttinen funktio, voidaan määritellä funktio, joka palauttaa toisen funktion sitoen argumenttinsa palauttamansa funktion vartalossa.

\subsection{Lisp}
Ensimmäinen funktionaaliseen ohjelmointiin soveltuva kieli oli listojen käsittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1960 John McCarthy \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispissä, kuten lähes kaikissa funktionaalisissa kielissä, on perustietorakenteena lista ja alkeisoperaattoreina funktiot, jotka palauttavat listan ensimmäisen solmun tai listan hännän. McCarthy halusi kieleensä mahdollisuuden käyttää funktioita argumentteina, ja lambda-laskenta tarjosi siihen sopivan notaation \cite[s.6]{historyoflisp}. 

\subsection{Muita funktionaalisiseen ohjelmointiin soveltuvia kieliä}
Muita funktionaaliseen ohjelmointiin soveltuvia kieliä ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. Näistä ainoastaan Haskell on ainostaan funktionaaliseen ohjelmointiin suunniteltu kieli. Muut kielet ovat joko multiparadigmakieliä tai mahdollistavat piirteitä jotka eivät kuulu funktionaaliseen ohjelmointiin. Esimerkiksi Schemessä on \textit{let-lause} jonka avulla voi määritellä muuttujia. Erlang on Ericssonin kehittämä tosiaika-ohjelmointiin soveltuva kieli. Scala on Java-alustalla toimiva kieli.

\section{Haskell}
Funktionaalisten ohjelmointikielten tutkimus oli kovassa nousussa 1980-luvun loppupuolella, jonka seurauksen myös funktionaalisten kielten määrä kasvoi voimakkaasti. Hyvin pian tutkijat pääsivät yhteisymmärrykseen siitä että tarvittiin yleinen standardoitu funktionaalinen ohjelmointikieli. Standardoinnin tuloksena syntyi loogikko Haskell B. Curryn mukaan nimetty Haskell \cite{haskellreport}. Kielen ensimmäinen versio julkaistiin vuonna 1990. Seuraavina vuosina Haskell kehittyi voimakkaasti, ja 1999 julkaistiin seuraava vakaa standardi, Haskell 98. Tässä kirjoitelmassa esitetyt esimerkit on kirjoitettu Haskell 98-standardin mukaisesti. Haskell kehittyy edelleen, seuraava versio, eli Haskell', on tulossa 2010.

Haskell on moderni yleiskäyttöinen funktionaalinen ohjelmointikieli, ja de facto-standardi funktionaalisten ohjelmointikielten tutkimuksessa. 

\subsection{Lausekkeita, arvoja ja tyyppejä}
Funktionaalisessa ohjelmoinnissa kaikki laskenta tapahtuu evaluoimalla \textit{lausekkeita} (expression), jolloin tuloksena saadaan \textit{arvoja} (value). Jokaiseen arvoon liittyy \textit{tyyppi} (type). Lausekkeita ovat atomiset arvot kuten kokonaisluku \texttt{7} tai merkki \texttt{'a'}, funktiot kuten \texttt{$\backslash$x->x+1}, totuusarvot kuten \texttt{True}, sekä yhdistelmätyypit kuten lista \texttt{[1,2,3]} ja pari \texttt{(1, 'a')}. 

Arvoihin liittyviä tyyppejä voivat olla esimerkiksi \texttt{Integer} (kokonaisluvut), \texttt{Char} (merkit), \texttt{Integer -> Integer} (funktiot jotka kuvaavat kokonaisluvut kokonaisluvuille), \texttt{Bool} (totuusarvot), \texttt{[Integer]} (kokonaisluvuista koostuva lista) ja \texttt{(Integer, Char)} (kokonaisluvuista ja merkeistä koostuvat parit).

Edelliset arvoesimerkit ja niihin liittyvät tyypit voidaan merkitä seuraavasti:
\begin{verbatim}
                          7 ::  Integer
                        'a' ::  Char
                    [1,2,3] :: [Integer]
                   (1, 'a') :: (Integer, Char)
                    \x->x+1 :: Integer -> Integer
                       True :: Bool
\end{verbatim}
Merkintä \texttt{a :: b} tarkoittaa että lauseke \texttt{a} on tyyppiä \texttt{b}. Tyyppien, kuten \texttt{Integer}, nimet tulee kirjoittaa isolla alkukirjaimella, ja arvoa merkitsevien nimien pienellä.

\subsection{Funktiot}
Funktiot määritellään Haskellissa yhtälöinä. Esimerkiksi funktio joka ottaa parametrinaan yhden kokonaisluvun ja korottaa sen arvoa yhdellä, voidaan määritellä näin:
\begin{verbatim}
 inc n = n + 1
\end{verbatim}
Haskellin tyyppijärjestelmä osaa päätellä lausekkeiden tyypit, mutta lisäämällä tyyppiannotaatio voidaan välttää virheitä, ja lisätä koodin luettavuutta. Funktion tyypin voi merkitä tyyppiannotaatiolla näin:
\begin{verbatim}
 inc          :: Integer -> Integer
\end{verbatim}
Funktio \texttt{inc} on siis kuvaus kokonaislukujen joukosta kokonaislukujen joukkoon. Funktion määritelmä voidaan kirjoittaa tyyppiannotaation kanssa seuraavasti:
\begin{verbatim}
 inc          :: Integer -> Integer
 inc n = n + 1
\end{verbatim}
Ehtolausekkeita käytetään Haskellissa seuraavan esimerkin mukaisesti:
\begin{verbatim}
 boolToInt b = if b then 1 else 0
\end{verbatim}
Seuraava esimerkki havainnollistaa \textit{ehtojen} (guards) käyttöä funktion määrittelyssä:
\begin{verbatim}
 boolToInt2 b | b == True = 1
              | otherwise = 0
\end{verbatim}
Ehto on pystyviivan ja yhtäsuuruusmerkin (\texttt{=}) välissä oleva lauseke, joka on tyyppiä \texttt{Bool}. \texttt{otherwise} on synonyymi arvolle \texttt{True}. Ehdot käydään järjestyksessä läpi ylhäältä alas. Jos jokin ehdoista evaluoituu todeksi, pysäytetään läpikäynti ja funktio saa arvoksi yhtälön oikean puolen arvon. \texttt{boolToInt} ja \texttt{boolToInt2}-funktioiden tyyppi on \texttt{Bool -> Integer}.
%%% /FUNKTIOT ==============================================================================================

%%% OPERAATTORIT ==========================================================================================
\subsection{Operaattorit}
Haskell sisältää kaikki tavanomaiset sisämerkintäoperaattorit, kuten yhteenlaskun \texttt{+}, miinuslaskun \texttt{-}, jakolaskun \texttt{/}, kertolaskun \texttt{*} sekä muita tarpeellisia operaattoreita. Operaattorit saattavat assosioida vasemmalle, kuten edellämainitut, tai oikealla, kuten potenssioperaattori \texttt{\^}. Lisäksi Haskell tarjoaa kaksi listojen käsittelyyn soveltuvaa operaattoria, listakonstruktori \texttt{:}, ja listojen yhdistysoperaattori \texttt{++}. Operaattoreille on määritelty normaalit presedenssit, esimerkiksi kertolasku sitoo tiukemmin kuin yhteenlasku. Sisämerkintäoperaattoreilla on myös tyyppi, esimerkiksi kertolaskuoperaattorin tyyppi on \texttt{(Num a) => a -> a -> a}. Tässä merkintä \texttt{Num a =>} tarkoittaa että kertolaskuoperaattorin argumentit ovat tyyppiä \texttt{a} joka toteuttaa tyyppiluokassa \texttt{Num} määritellyt funktiot. Haskellin operaattorit eroavat funktioista kahdella tapaa, funktion sovellus argumenttiinsa sitoo tiukemmin kuin operaattorin sovellus argumenttiinsa ja funktioille ei voi määritellä presedenssiä.

Funktionaalisissa ohjelmointikielissä kuten Haskellissa, lista on usein määritelty alkeistietotyyppinä. Listaoperaattoreita (\texttt{:}, \texttt{++}) voidaan käyttää listojen konstruoinnissa seuraavasti:
\begin{verbatim}
 concatenate :: [Integer] -> [Integer] -> [Integer]
 concatenate l1 l2 = l1 ++ l2

 addToList :: Integer -> [Integer] -> [Integer]
 addToList n l = n:l

 empty :: [a] -> Bool
 empty [] = True
 empty _ = False
\end{verbatim}
Operaattori \texttt{++} siis yhdistää kaksi listaa. Lauseke \texttt{concatenate [1,2] [3,4]} evaluoituu arvoksi \texttt{[1,2,3,4]}. Operaattori \texttt{:} lisää ensimmäisenä argumenttinaan saamansa kokonaisluvun toisena argumenttina saadun kokonaislukulistan kärkeen. Lauseke \texttt{addToList 1 [2,3,4]} evaluoituu arvoksi \texttt{[1,2,3,4]}. Funktio \texttt{empty} testaa listan tyhjyyttä. Merkintä \texttt{[]} tarkoittaa tyhjää listaa, ja jos funktiolle \texttt{empty} annetaan parametrina tyhjä lista, se palautta \texttt{True}. Muussa tapauksessa funktio palauttaa \texttt{False}.  
%%% /OPERAATTORIT ==========================================================================================

%%% UUSIEN TIETOTYYPPIEN MÄÄRITTELY ========================================================================
\subsection{Uusien tietotyyppien määrittely}
Uusia tyyppejä voi määritellä avainsanan \texttt{data} avulla. Esimerkiksi totuusarvot määritellään näin:
\begin{verbatim}
 data Bool         = False
                   | True
\end{verbatim}
Uuden tyypin määritelmä on yhtälö, jossa yhtäsuuruusmerkin vasemmalla puolella annetaan uuden \textit{tyyppikonstruktorin} (type constructor) nimi, ja yhtäsuuruusmerkin oikealla puolella annetaan uusien \textit{arvokonstruktorien} (value constructors, data constructors) nimi tai nimet pystyviivalla erotettuina. Merkintä tarkoittaa että arvokonstruktoreilla \texttt{False} ja \texttt{True} voi luoda \texttt{Bool}-tyyppisiä arvoja. Tässä tapauksessa sekä tyyppi- että arvokonstruktorit ovat parametrittomia. \texttt{Bool} on enumeroituva tyyppi, koska se koostuu äärellisestä määrästä parametrittomia arvokonstruktoreita. Arvokonstruktorit ovat analogisia Javan konstruktoreiden kanssa. 

%% Listoista
%Funktionaalisissa ohjelmointikielissä kuten Haskellissa, lista on usein määritelty alkeistietotyyppinä. Lista voidaan määritellä myös seuraavasti:
%\begin{verbatim}
%data List a = Nil
%            | Cons a (List a)
%\end{verbatim}
%Määritelmän ensimmäisen rivi määrittelee tyyppikonstruktorin \texttt{List a}, jonka parametri \texttt{a} on tyyppimuuttuja. \texttt{Nil} on tyhjä arvokonstruktori joka vastaa tyhjää listaa. Listaan voi sijoittaa minkätyyppisiä arvoja tahansa, myös funktioita. Määritelmän toisella rivillä määritellään kaksiparametrinen arvokonstruktori \texttt{Cons}, jonka tyyppi on \texttt{a -> List a -> List a}. Arvokonstruktorin ensimmäinen parametri on jokin listaan tallennettava arvo, ja toinen parametri on listan häntä, joka voi olla tyhjä tai lista samantyyppisiä arvoja. Haskellissa merkintä \texttt{[]} tarkoittaa tyhjää listaa, ja operaattori \texttt{:} on vastaa arvokonstruktori \texttt{Cons}:ia. 

Kokonaislukuja säilövä binääripuu voidaan määritellä seuraavasti:
\begin{verbatim}
 data BinaryTree   = EmptyTree
                   | BinaryTree Integer BinaryTree BinaryTree 
\end{verbatim}
Nyt tyyppikonstruktori ja toinen arvokonstruktori ovat samannimisiä. Tämä on mahdollista, koska Haskellissa tyyppikonstruktorit ja arvokonstruktorit asuvat eri nimiavaruuksissa, jolloin ei ole vaaraa niiden sekoittumisesta. \texttt{EmptyTree} on parametriton arvokonstruktori joka luo tyhjän puun. Arvokonstruktori \texttt{BinaryTree} ottaa parametreikseen kokonaisluvun ja kaksi tyyppiä \texttt{BinaryTree} olevaa binääripuuta, joista ensimmäinen on puun vasen oksa, ja toinen on puun oikea oksa. Arvokonstruktorit ovat oikeastaan funktioita, esimerkiksi tässä tapauksessa arvokonstruktori \texttt{BinaryTree}:n tyyppi on \texttt{Integer -> BinaryTree -> BinaryTree -> BinaryTree}. Koska tyypin \texttt{BinaryTree} toisessa arvokonstruktorissa on kaksi \texttt{BinaryTree} tyyppistä parametria, on \texttt{BinaryTree} rekursiivinen tietotyyppi. Muotoa \texttt{a -> b -> c} oleva funktion tyyppimerkintä tarkoittaa että funktiolla on kaksi parametria tyyppiä \texttt{a} ja \texttt{b}, ja lopuksi funktio palauttaa tyyppi \texttt{c} olevan arvon. Arvokonstruktorien kuten \texttt{True} ja \texttt{BinaryTree} nimet tulee kirjoittaa isolla alkukirjaimella.
%% Parametrisoitu monimuotoisuus myöhemmin, listojen yhteydessä
%%% / UUSIEN TIETOTYYPPIEN MÄÄRITTELY ======================================================================

\subsection{Tyyppisynonyymit}
Haskell tarjoaa yksinkertaisen rakenteen jolla määritellä \texttt{tyyppisynonyymeja} (type synonyms). Esimerkiksi Haskell 98 -standardissa \texttt{String} on määritelty tyyppisynonyymiksi merkkilistalle (\texttt{[Char]}). Tyyppisynonyymeja määritellään seuraavan esimerkin mukaan.
\begin{verbatim}
type String = [Char]

type Name = String
type Address = String
data Person = (Name, Address)
\end{verbatim}
\texttt{Person} on tyyppi joka koostuu nimi-osoite-parista. Tyyppisynonyymit parantavat lähdekoodin luettavuutta.

%%% TYYPPILUOKAT ===========================================================================================
\subsection{Tyyppiluokat}
\textit{Tyyppiluokka} (type class) esittelee joukon funktioita, jotka kyseisen tyyppiluokan toteuttavien tyyppien tulee toteuttaa. Kyseessä on siis Javan rajapintoja vastaava ominaisuus. Merkintä \texttt{(TyyppiLuokka a) => a} tarkoittaa että tyyppi \texttt{a} toteuttaa tyyppiluokassa \texttt{TyyppiLuokka} esitellyt funktiot. Esimerkiksi yhtäsuuruusoperaattorin (\textit{==}) tyyppimerkintä \texttt{(==) :: (Eq a) => a -> a -> Bool} tarkoittaa että yhtäsuuruusoperaatorilla voidaan verrata kaikkia niitä tyyppejä \texttt{a}, jotka toteuttavat tyyppiluokan \texttt{Eq}, ja yhtäsuuruusoperaattorin paluuarvo on tyyppiä \texttt{Bool}. 

%Jos esimerkiksi halutaan kirjoittaa funktio joka tutkii onko parametrina annettu alkio toisena parametrina annetun listan jäsen, se voidaan kirjoittaa näin:
%\begin{verbatim}
%x 'elem' []     = False
%x 'elem' (y:ys) = x==y || (x 'elem' ys)
%\end{verbatim}
%Merkintä \texttt{[]} tarkoittaa tyhjää listaa. Kirjoittamalla heittomerkit funktion nimen ympärille, sitä voidaan käyttää sisämerkintätyyliin (infix). Määritelmän ensimmäinen rivi tarkoittaa että jos toinen parametri on tyhjä lista, ei haluttu alkio voi löytyä sieltä ja funktio evaluoituu epätodeksi. Toinen rivi tarkoittaa että, jos alkio \texttt{x} on yhtäsuuri kuin listan ensimmäinen alkio \texttt{y}, palautetaan tosi, muutoi
%% rekursio ei vielä käsitelty....

Tyyppiluokka \texttt{Eq} määritellään näin:
\begin{verbatim}
class Eq a where
	(==)	:: a -> a -> Bool
\end{verbatim}
Tässä siis \texttt{Eq} on tyyppiluokan nimi, ja yhtäsuuruusoperaattori \texttt{==} on ainoa tyyppiluokassa määritelty operaattori.

Jotta yhtäsuuruusoperaattoria voitaisiin käyttää esimerkiksi liukulukujen (\texttt{Float}) vertailuun, tulee tyypin \texttt{Float} toteuttaa tyyppiluokan \texttt{Eq} esittelemät operaattori ja funktiot. 
\begin{verbatim}
instance Eq Float where
	x == y 		= x 'floatEq' y
\end{verbatim}
Tässä \texttt{floatEq} on alkeisfunktio joka vertaa kahden liukuluvun yhtäsuuruutta. Laittamalla funktio heittomerkkien väliin sitä voidaan käyttää sisämerkintätyyliin. 

%%% /TYYPPILUOKAT ===========================================================================================

%% FUNKTIONAALISEN OHJELMOINNIN ERITYISPIIRTEITÄ
\section{Funktionaalisen ohjelmoinnin erityispiirteitä}
Tässä kappaleessa esitellään funktionaalisen ohjelmointityylin käsitteitä ja ominaisuuksia esimerkkien kera. Kaikki esimerkit on kirjoitettu Haskell 98 -standardin mukaisesti. Funktionaalisen ohjelmoinnin piirteitä verrataan usein \textit{imperatiiviseen ohjelmointiin} (imperative programming). Imperatiivisella ohjelmoinnilla tarkoitetaan yleisintä olevaa ohjelmointitapaa, jossa laskentaa simuloidaan muuttamalla ohjelman tilaa (state), eli muuttujien arvoja, tietyssä järjestyksessä suoritetuilla lauseilla. Tälläisiä ohjelmointikieliä ovat mm. C, C++, Java ja Pascal. Imperatiivinen ohjelmointi siis kattaa proseduraalisen ja olio-ohjelmoinnin. 

\subsection{Hahmontunnistus}
\textit{Hahmontunnistus} (pattern matching, kuuluu olennaisesti nykyaikaisiin funktionaalisiin kieliin \cite[s. 388]{Hudak89}. Funktio voidaan määritellä eri hahmoina, joita vastaan lausekketta sitten yritetään tunnistaa. Esimerkiksi kaksiparametriset loogiset konnektiivit \texttt{or} ja \texttt{and} voidaan määritellä eri hahmojen avulla seuraavasti:
\begin{verbatim}
 or True _ = True
 or _ True = True
 or _ _    = False

 and True True = True
 and _ _ = False
\end{verbatim}
Funktion \texttt{or} määritelmän ensimmäin rivi sisältää hahmon \texttt{True \_}, joka tarkoittaa tapausta jossa funktion ensimmäinen argumentti on tosi. Toisen argumentin arvolla ei tällöin ole väliä ja lauseke evaluoituu todeksi. Määritelmän toisen rivin hahmo \texttt{\_ True} taas vastaa tapausta jossa toinen argumentti on tosi, jolloin ensimmäisen argumentin arvolla ei ole väliä ja lauseke evaluoituu todeksi. Funktion \texttt{or} määritelmän kolmannen yhtälön hahmo \texttt{\_ \_} sopii kaikkkiin mahdollisiin parametriyhdistelmiin. Koska tässä vaiheessa on jo käyty läpi vaihtoehdot joissa ensimmäinen, toinen tai molemmat argumentit olisivat tosia, saadaan tällä yhtälöllä kiinni vain tapaukset joissa molemmat argumentit ovat epätosia. Alaviiva (\texttt{\_}) sopii mihin tahansa hahmoon. Molemmat funktiot ovat tyyppiä \texttt{Bool -> Bool -> Bool}

Funktio \texttt{empty}, joka tutkii onko parametrina annettu binääripuu tyhjä, voidaan kirjoittaa näin:
\begin{verbatim}
 empty EmptyTree = True
 empty _         = False
\end{verbatim}
Funktion tyyppi on \texttt{BinaryTree -> Bool}.

Hahmontunnistusta käytetään usein listojen kanssa. 
\begin{verbatim}
 head (x:_) = x

 tail (_:xs) = xs
\end{verbatim}
Funktio \texttt{head} palauttaa listan ensimmäisen alkion. Hahmo \texttt{(x:xs)} vastaa listaa jonka ensimmäinen alkio on \texttt{x}, ja lista loppuosa on \texttt{xs}. Funktio \texttt{tail} taas palauttaa listan loppuosan, siis argumenttina annetun listan ilman ensimmäistä alkiotaan. 

\subsection{Puhtaat funktiot ja sivuvaikutuksettomuus}
%% SIVUVAIKUTUKSET
Funktiolla sanotaan olevan \textit{sivuvaikutuksia} (side effects) jos se muuttaa ohjelman tilaa tai vaikuttaa ulkomaailmaan muuten kuin paluuarvonsa kautta \cite[s.238]{scott}. Imperatiivisessa ohjelmoinnissa ohjelman tila on sen paikallisten ja globaalien muuttujien arvo tiettynä hetkenä, ja kaikki ohjelmointi, missä muutetaan kyseisten muuttujien arvoa on sivuvaikutuksellista ohjelmointia. Imperatiivinen ohjelmointityyli perustuu nimenomaan ohjelman tilan muuttamiseen. Kun imperaativisessa ohjelmoinnissa lause \texttt{nimi = arvo} tarkoittaa arvon sijoittamista johonkin muistipaikkaan, niin funktionaalisessa ohjelmassa vastaava merkintä tarkoittaa että \texttt{nimi} on lyhennysmerkintä arvolle.  


%Imperatiivisessa ohjelmassa kyseistä arvoa ei kuitenkaan voi jokaisessa sen esiintymiskohdassa korvata sen sijoituspaikan nimellä, koska sijoituspaikkaan on voitu kirjoittaa uusi arvo. Puhtaassa funktionaalisessa ohjelmoinnissa taas \texttt{nimi} ja \texttt{arvo} merkitsevät samaa asiaa joten ne 

%% nimi = arvo WTF!!!

%%, eikä arvon sijoittamista johonkin muistipaikkaan, kuten imperatiivisessa ohjelmoinnissa.
%% ohjelmoinnissa muuttujaa ajatellaan yleensä muistipaikan nimenä, matematiikassa arvon nimenä
%% fp:ssä ei sijoituslauseita, vaan merkintöjä x=y mitkä tarkoittavat tämä(y) on lyhennys tuolle(x)
%% tämä nimi on lyhennysmerkintä tuolle arvolle nimi= arvo
%% Imperatiivinen ohjelmointi on sarja järjestettyjä muutoksia ohjelman muuttujiin. jokainen muutos implikoi tilanvaihdosta

%% PUHTAAT FUNKTIOT
\textit{Puhtaat funktiot} (pure functions) ovat funktioita matemaattisessa merkityksessä. Ohjelmoinnista puhuttaessa saatetaan funktioiksi kutsua jopa aliohjelmia joiden laskennan tulos riippuu jostain globaalista muuttujasta, jolloin saattaa päteä \textit{f(x) $\ne$ f(x)} eri kutsuhetkinä. Matemaattisilla funktioilla ei ole tilaa, eikä sivuvaikutuksia. Matemaattiset funktiot ovat kuvauksia lähtöjoukosta (domain) maalijoukkoon (range), ja ne palauttavat samoilla argumenteilla aina saman paluuarvon. Tästä seuraa että funktiokutsu voidaan korvata sen laskennan tuloksella, ja toisinpäin. Tätä ominaisuutta kutsutaan \textit{viittausten läpikuultavuudeksi} (referential transparency). Imperatiivisessa ohjelmassa tämä ei välttämättä päde koska laskennan tulos voi riippua ulkopuolisten muuttujien arvoista jolloin funktio laskee eri tuloksen eri kutsukerroilla. Toisaalta jokin toinen funktio voi kirjoittaa muuttujaan johon on tallennettu funktion paluuarvo ja näin funktiokutsua ei voi korvata muuttujalla johon on sijoitettu sen laskennan tulos. Viittausten läpikuultavuus helpottaa suuresti ohjelmien oikeellisuuden todistamista \cite[s.362]{Hudak89}.

Viittausten läpikuultavuus antaa kääntäjälle mahdollisuuden korvata monta kertaa ohjelmassa esiintyvä lauseke sen arvolla, jolloin lausekkeen arvoa ei tarvitse laskea kuin kerran.
%% TODO: salliiko alkuperäinen lisp sivuvaikutukset

Funktionaalisessa ohjelmoinnissa ohjelma koostetaan puhtaista funktiosta, joilla ei siis ole tilaa eikä sivuvaikutuksia. Näin funktionaalinen ohjelmointi on tila- ja sivuvaikutuksetonta. Jotkin kielet, kuten Lisp ja sen johdannaiset, sallivat sivuvaikutukset joten ne eivät ole puhtaita funktionaalisia kieliä, vaan pikemminkin hybridikieliä joissa on tuki funktionaaliselle ohjelmoinnille. Tilattomuudesta seuraa että muuttujien arvoja ei voi muuttaa niiden luonnin jälkeen. 
%% TODO: Scheme tarjoaa let-lauseen??? SICP
%% TODO: sivuvaikutusten salliminen
%% TODO: tässä kirjoitelmassa muuttuja ei ole kuin imperatiivisessa

Sivuvaikutuksettomuudella on sekä myönteisiä että kielteisiä seurauksia. Koska funktionaalisessa ohjelmoinnissa ei muokata tilaa, ei myöskään tietorakenteita pysty muokkaamaan niiden luonnin jälkeen, vaan esimerkiksi poistettaessa listasta alkio, luodaan uusi lista vanhan listan kopiona ilman poistettavaa alkiota. Suuria tietorakenteita kuten tietokantoja ei voida toteuttaa tehokkasti ilman sivuvaikutuksia. Jos esimerkiksi halutaan muuttaa yhden rivin yhden sarakkeen arvo tietokannassa jossa on miljoonia rivejä, tulisi muutoksen tekevän funktion palauttaa kokonaan uusi tietokanta. Lisäksi siirräntä, syöttö ja tulostus, on luonteeltaan sivuvaikutuksellista. Siirräntään tosin on kehitetty elegantteja funktionaalisia ratkaisuja. 
%%(TODO: lähde, Haskell:n stream ja monad io),tietorakenteista, optimoiva kääntäjä?P
%% TODO: yllä ja allaoleva lukijan mielestä ristiriitaisia.
Sivuvaikutukseton ohjelmointi ei siis sovi kaikkeen. Sivuvaikutuksettomuudesta kuitenkin seuraa että funktioiden suoritus voidaan huoletta rinnakkaistaa ja ohjelmien tuotantokustannukset laskevat koska ohjelmia on helpompi laatia, korjata ja ylläpitää \cite[s.527]{scott}.
%TODO: jotain muuta sivuvaikutuksettomuudesta? Tietorakenteen ja sivuvaikutukset? Funktionaaliset tietorakenteet? sivuvaikutusten parempi määritelmä

%% TODO: Toinen virke palaa ensimmäiseen virkkeeseen....
%% FUNKTIOT ENSIMMÄISEN LUOKAN ARVOINA
\subsection{Funktiot ensimmäisen luokan arvoina} 
\textit{Ensimmäisen luokan arvo} (first class value) voidaan välittää parametrina, palauttaa funktion paluuarvona tai luoda suoritusaikana \cite[s.526]{scott}. Funktionaalisessa ohjelmoinnissa funktiot ovat ensimmäisen luokan arvoja, kun taas imperatiivisessa ohjelmoinnissa funktiot ovat yleensä toisen luokan arvoja, eikä niitä ei voi välittää parametreina, palauttaa paluuarvoina tai luoda suoritusaikana. Jotkut imperatiiviset kielet kuten C tukevat funktio-osoittimien välittämistä parametreina. Funktioita ei C:ssä kuitenkaan voi luoda suoritusaikana jolloin ne eivät ole ensimmäisen luokan arvoja. Oliokielistä SmallTalk tukee funktioita ensimmäisen luokan arvoina. Yleisesti käytössä olevissa kielissä alkeistyyppiset arvot kuten kokonaisluvut, liukuluvut, merkit, merkkijonot ja oliot ovat ensimmäisen luokan arvoja. 

%% TODO: taitaa olla vähän päin vittua!!
Koska ensimmäisen luokan arvoja voi luoda ohjelmalohkojen sisällä, voidaan määritellä funktio, jonka määrittelyssä käytetään sen määrittelylohkossa näkyviä muuttujia. Funktio voidaan edelleen välittää parametrina toiselle funktiolle jolloin funktion käyttämät muuttujat ovat näkyvyysalueensa ulkopuolella, ja niitä ei voi vapauttaa muistinhallinnan toimesta, kun funktion määrittelylohkon käyttämä muisti vapautetaan. Funktiota, jonka määrittelyssä näin käytetään määrittelylohkonsa muuttujia, kutsutaan \textit{sulkeumaksi} (closure).
%% Sulkeumilla voidaan toteuttaa tila?

%% KORKEAMMAN KERTALUVUN FUNKTIOT
\subsection{Korkeamman kertaluvun funktiot}
\textit{Korkeamman kertaluvun funktioiksi} (higher order functions, functional forms) kutsutaan funktioita jotka ottavat parametrinaan toisen funktion, tai palauttavat paluuarvonaan funktion \cite[s. 546]{scott}. Yksi yleisimpiä tapoja käyttää korkeamman kertaluvun funktioita on rakentaa niiden avulla uusia funktioita. Esimerkiksi Haskell-kielen \textit{map}-funktio ottaa parametrinaan funktion ja listan, ja käy listan rekursiivisesti läpi soveltaen parametrinaan saamaa funktiota jokaiselle listan alkiolle. 

Määritellään funktio \texttt{twice} siten että se soveltaa parametrina saamaansa funktiota toisena parametrina saamaansa arvoon. 
\begin{verbatim}
 twice f n = f (f n)
\end{verbatim}
Haskell osaa päätellä funktion tyypiksi \texttt{(t -> t) -> t -> t}. Nyt lauseke \texttt{twice inc 5} evaluoituu ensin muotoon \texttt{inc (inc 5)} ja sitten muotoon \texttt{inc 6} ja lopuksi laskennan tuloksena saadaan \texttt{7}.

%% TODO: silmukka pois, for,while,loop on toistoa, rekursio rekursiota, toisto saavutetaan rekursiolla
\subsection{Rekursio}
Imperatiivisessa ohjelmoinnissa toisto saadaan aikaan \texttt{for}-, \texttt{while}- tai \texttt{loop}-lauseilla. Yleisessä tapauksess nämä lauseet tutkivat jonkin muuttujan tilaa, ja sen perusteella päättävätä suoritetaanko niihin liitetty koodilohko uudestaan vai ei. Funktionaalisessa ohjelmoinnissa toisto saadaan aikaan rekursiolla. Klassinen esimerkki rekursiosta on kertomafunktio:
\begin{verbatim}
 factorial :: Integer -> Integer
 factorial 0 = 1
 factorial n | n > 0 = n * factorial (n-1)
             | otherwise = -1
\end{verbatim}
Funktio \texttt{factorial} siis kuvaa kokonaislukujen joukon kokonaisluvuille. Funktion sovellus nollaan evaluoituu ykköseksi. Jos funktiolle annettu parametri on suurempi kuin nolla, kutsutaan rekursiivisesti \texttt{factorial}-funktiota jotta saadaan luvun \texttt{n-1} kertoma. Nollaa pienemmille luvuille kertomaa ei ole määritelty. Funktio \texttt{factorial} on määritelty hahmontunnistuksen avulla, ensimmäisessä yhtälössä hahmo johon argumenttia sovitetaan on \texttt{0}, ja toisessa yhtälössä \texttt{n} (johon sopii kaikki kokonaisluvut).

Listat ovat funktionaalisissa kielissä tärkeitä koska niillä on luonnollinen rekursiivinen määritelmä. Lista voidaan määritellä vaikkapa näin:
\begin{verbatim}
 data List a = Nil
             | Cons a (List a)
\end{verbatim}
Tässä \texttt{Nil} on parametriton arvokonstruktori jolla luodaan tyhjä lista. Haskellissa vastaava parametriton arvokonstruktori on \texttt{[]}. \texttt{Cons a (List a)} on kaksiparametrinen arvokonstruktori joka luo uuden listan. Haskelin vastaava arvokonstruktori on sisämerkintäoperaattori \texttt{:}. 

Allaolevassa esimerkissä on kolme eri tapaa merkitä lista jolla on alkiot \texttt{1}, \texttt{2} ja \texttt{3}. Ensimmäisen rivin esimerkki on oman määritelmämme mukainen lista. Keskimmäinen lista on Haskellin standardi tapa merkitä lista. Kolmas esimerkki on syntaktista sokeria keskimmäiselle merkinnälle. 
\begin{verbatim}
 Cons 1 (Cons 2 (Cons 3 Nil))
 1 :  (2 : (3 : []))
 [1,2,3]
\end{verbatim}
Funktio \texttt{length} joka laskee listan pituuden voidaan määritellä seuraavasti:
\begin{verbatim}
 length [] = 0
 length (x:xs) = 1 + (length xs)
\end{verbatim}
Mikäli funktion argumenttina on tyhjä lista, evaluoituu lauseke arvoon \texttt{0}. Jos argumenttina olevassa listassa on vähintään yksi alkio, evaluoituu funktion paluuarvoksi listan loppuosan pituus lisättynä yhdellä.

Esimerkiksi lauseke \texttt{length [4,5,1,8,3]} evaluoituu seuraavasti:
\begin{verbatim}
 length [4,5,1,8,3]
 1 + (length [5,1,8,3])
 1 + (1 + (length [1,8,3]))
 1 + (1 + (1+ (length [8,3])))
 1 + (1 + (1+ (1+ (length [3]))))
 1 + (1 + (1+ (1+ (1 + (length [])))))
 1 + (1 + (1+ (1+ (1 + (0)))))
 1 + (1 + (1+ (1+ (1))))
 1 + (1 + (1+ (2)))
 1 + (1 + (3))
 1 + (4)
 5
\end{verbatim}
Laskennan tuloksena on siis \texttt{5}.

Yleinen listojen kanssa käytetty funktio on \texttt{map}, joka soveltaa ensimmäisenä argumenttinaan saamaansa funktiota toisena argumenttina saamansa listan jokaiselle alkiolle. Funktion tyyppi on \texttt{(a -> b) -> [a] -> [b]}. Funktio \texttt{map} voidaan määritellä näin:
\begin{verbatim}
 map _ []     = []
 map f (x:xs) = f x : map f xs 
\end{verbatim}
Lauseke \texttt{map inc [0,1,2]} evaluoituu näin:
\begin{verbatim}
 map inc [0,1,2]
 inc 0 : map inc [1,2]
 inc 0 : inc 1 : map inc [2]
 inc 0 : inc 1 : inc 2 : map inc []
 inc 0 : inc 1 : inc 2 : []
 inc 0 : inc 1 : 3 : []
 inc 0 : inc 1 : [3]
 inc 0 : 2 : [3]
 inc 0 : [2,3]
 1 : [2,3]
 [1,2,3]
\end{verbatim}
Tässä \texttt{:} on sisämerkintäoperaattori, jolla luodaan uusi lista. Operaattori \texttt{:} on tyyppiä \texttt{a -> [a] -> [a]}.

%% TODO: FOLD!!!

Toinen yleinen listojen käsittelyyn soveltuva on \texttt{foldl}.

Esimerkiksi kertoma voidaan määritellä funktion \texttt{foldl} avulla näin:
\begin{verbatim}
 factorial2 0 = 1
 factorial2 n  = foldr (*) 1 [1..n]
 factorial2 _ = -1
\end{verbatim}


\subsection{Evaluointijärjestys}
Funktionaalisten ohjelmien evaluoimiseen on vakiintunut kaksi tapaa. \textit{Tiukassa evaluaatiossa} (strict evaluation) lausekkeet, erityisesti funktioiden argumentit, evaluoidaan aina, oli siihen tarvetta tai ei. Tiukan mallin avulla voidaan käännösaikana tunnistaa päättymättömät lausekkeet, toisin sanoen lausekkeet jotka eivät evaluoidu, vaan hajaantuvat. Haittapuolena pitää ohjelmien määrittelyssä olla tarkkana, sillä väärä määrittelyjärjestys voi johtaa siihen että sinänsä validi ohjelma ei käänny. 
%% TODO: epämääräinen
Tiukan evaluaation vastakohta on \textit{laiska evaluaatio} (lazy evaluation), jossa lausekkeiden arvot evaluoidaan vasta kun niitä tarvitaan. Esimerkiksi, jos listan ensimmäisen alkion palauttavalle funktiolle annetaan argumenttina päättymätön lista niin tiukkaa evaluaatiota käyttävä ohjelma ei edes käänny kun taas laiskaa evaluaatiota käyttävä ohjelma evaluoi listasta vain sen ensimmäisen alkion. Funktionaalinen ohjelmointikieli on laiska, jos se evaluoi lausekkeensa laiskasti. Yleisesti ottaen laiskat kielet ovat nopeampia kuin tiukat, johtuen siitä että ne eivät yritä evaluoida kaikkia lausekkeita.
%% TODO: funktionaalisen ohjelmointikielen laiskuus, lähde!!
%% TODO: hajaantuvat? selitys 

Yleisesti imperatiiviset kielet käyttävät tiukkaa evaluaatiota. Funktionaaliseen ohjelmointiin sopivista kielistä Lisp ja sen johdannaiset käyttävät tiukkaa evaluaatiota, tosin Schemeen on lisätty tuki laiskalle evaluaatiolle. Haskell sen sijaan käyttää laiskaa evaluaatiota. 
%% TODO: scheme lähde

%\textit{Laiska evaluatio} (engl. \textit{lazy evaluation, non-strict evaluation}), sivuvaikutuksettomuuden seuraus, mitä siitä seuraa, tiukka evaluaatio, laiskat tietorakenteet, haskell ja lisp, \textit{laiska funktio} 

\subsection{Tyypitys ja monimuotoisuus funktionaalisissa kielissä}

\textit{Dynaaminen tyypitys} (dynamic typing) tarkoittaa tyyppijärjestelmää, jossa tyypit tarkastetaan vasta suoritusaikana \cite[s.310]{scott}. Esimerkiksi useat skripti-kielet ja Lisp ovat dynaamisesti tyypitettyjä. Dynaaminen tyypitys tarkoittaa että mahdollisia tyyppivirheitä ei havaita vielä käännösaikana, vaan vasta suoritusaikana. Lisäksi suoritusaikainen tyyppitarkastus lisää ohjelman resurssivaatimuksia.
%% TODO: C on staattisesti ja heikosti tyypitetty kieli!!

Ohjelmointikielen sanotaan olevan \textit{vahvasti tyypitetty} (strongly typed) \cite[s.309]{scott}, jos se kieltää operaattorin tai funktion sovelluksen tyypille, jos funktio tai operaattori ei tue kyseistä tyyppiä. Vahva tyypitys ei myöskään salli tyyppien muuntamista toiseksi (type casting). Ohjelmointikielen sanotaan olevan \textit{staattisesti tyypitetty} \cite[s.309]{scott}, jos  tyyppien tarkastus voidaan tehdä käännösaikana. Funktionaalisista ohjelmointikielistä Haskell on staattisesti ja vahvasti tyypitetty. Imperatiivisista ohjelmointikielistä muun muassa Java ja C++ ovat staattisesti tyypitettyjä. Staattinen tyypitys auttaa ohjelmoijaa havaitsemaan tyyppivirheet käännösaikana.
 
%% TYYPPIEN PÄÄTTELEMINEN
\textit{Tyypin päätteleminen} (type inference), tarkoittaa sitä, että lausekkeen tyyppi voidaan johtaa lausekkeen käyttöympäristöstä tai joistain lausekkeen osista \cite[s.308]{scott}. Useat dynaamisesti tyypitetyt skriptikielet johtavat lausekkeiden tyypit suoritusaikana. Tyyppien johtaminen on yleisesti tuettua funktionaalisissa ohjelmointikielissä. Näin esimerkiksi Haskell-funktion määrittelystä voidaan jättää parametrien tyypitys pois. Esimerkiksi aikaisemmin esitelty \texttt{inc}-funktio voidaan määritellä ilman tyyppiannotaatiota:
\begin{verbatim}
  inc n = n + 1
\end{verbatim}
Haskell kääntäjä tai tulkki osaa päätellä funktion tyypiksi \texttt{Integer -> Integer} koska funktion määritelmässä yhtälön oikealla puolella sovelletaan \texttt{+}-operaattoria kokonaislukuun.

%% MONIMUOTOISUUS
\textit{Monimuotoisuus} (polymorphism) tarkoittaa sitä että yksi ohjelmalohko, funktio tai kokonainen ohjelma voidaan suorittaa monilla eri tyypeillä \cite[s.309]{scott}. Oliokielistä puhuttaessa monimuotoisuutta on kahdenlaista, geneeristä eli parametrista monimuotoisuutta joka mahdollistaa luokkien määrittelyn tyyppiparametrien kanssa. Toinen oliokielissä esiintyvä monimuotoisuuden muoto on alityypin monimuotoisuus, eli perintään perustuva monimuotoisuus. Funktionaalisissa ohjelmointikielissä on parametrinen monimuotoisuus yleistä. Alla parametrisesta monimuotoisuudesta esimerkkinä funktio \texttt{square}. 
\begin{verbatim}
  square :: (Num a) => a -> a 
  square n = n * n
\end{verbatim}
Funktion tyyppiannotaatiossa on tyyppimuuttuja \texttt{a} joka kertoo että funktio on monimuotoinen. Lisäksi tyyppiannotaatiosta näkee että funktio on määritelty kaikille tyypeille \texttt{a} jotka toteuttavat tyyppiluokan \texttt{Num} esittelemät funktiot, joihin kertolaskuoperaattori kuuluu.

%% oikeastaan tuo on ad hoc (overloading)monimuotoisuutta, 

 Funktionaalisissa kielissä monimuotoisuus on tärkeä ominaisuus, koska se sallii funktioiden käytön mahdollisimman monentyyppisillä parametreilla. Lisp ja sen johdannaiset ovat dynaamisesti tyypitettyjä, ja siten luonnostaan monimuotoisia. Koska Haskell-funktioiden parametrien tyyppiä ei tarvitse määritellä, saavuttaa Haskell monimuotoisuuden tyyppien johtamisen kautta. Esimerkiksi listoja käsittelevät funktiot ovat monimuotoisia. Yleensä ne eivät edes tiedä mitä tyyppiä listan alkiot ovat, koska ne ovat kiinnostuneita vain listan rakenteesta.
%% TODO: kahdenlaista monimuotoisuutta, parametrista ja ajonaikaisesta sidonnasta johtuvaa (??)

%% TODO: abstrakti tietotyyppi
%% TODO: Haskell-kielen tyyppijärjestelmä
%% FUNKTIONAALINEN SIIRRÄNTÄ
\subsection{Funktionaalinen siirräntä}
Siirräntä on sivuvaikutuksellisen luonteensa vuoksi ongelmallinen funktionaalisille ohjelmointikielille. Puhtaissa funktionaalisissa ohjelmointikielissähän funktiot palauttavat samoilla argumenteilla aina saman paluuarvon. Käyttäjältä syötteen lukeva \texttt{read}-funktiohan taas palauttaa käyttäjän syöttämän merkin tai merkkijonon, jolloin funktion paluuarvo vaihtelee kutsukerrasta toiseen.

\textit{Sekvenssointi} (sequencing) tarkoittaa ohjelmointikielen lauseiden suorittamista järjestyksessä. Funktionaalisissa ohjelmointikielissä lausekkeiden evaluointijärjestyksellä ei ole väliä. Siirräntää taas ei voi toteuttaa ilman että voidaan määrätä toimintojen järjestys.

%% TODO: tämä kappale paremmin!!!
Haskell toteuttaa siirrännän \textit{monadien} (monad) avulla. Monadi on on abstrakti tietotyyppi joka tukee sekvenssoinnin käsitettä. Haskellin siirräntämonadin arvot ovat \textit{toimintoja} (action), jotka ohjelmoija voi pakottaa suoritettavaksi tietyssä järjestyksessä \cite[s.543]{scott}. Toiminnot ovat funktionaalisesta siirrännästä puhuttaessa erilaisia luku- tai kirjoitustoimintoja. Haskellin siirräntämonadin funktiot joko palauttavat tai ottavat parametreikseen toimintoja. Esimerkiksi \texttt{getChar}-funktio palauttaa siirräntätoiminnon joka lukee syötteestä yhden merkin. Vastaavasti \texttt{putChar}-funktio palauttaa toiminnon joka kirjoittaa merkin ulostuloon. Siirräntätoimintoja palauttavien funktioiden kutsut tulee sekvensoida \texttt{do}-operaattorin avulla. 

Näin esimerkiksi yksinkertainen kaksi riviä tulostava Haskell ohjelma olisi seuraavanlainen:
\begin{verbatim}
  main = do putStr "Hoi \n"
            putStr "maailma!"
\end{verbatim}

\section{Yhteenveto}
Funktionaalinen ohjelmointi on kehittynyt matemaattisesta formalismista varteenotettavaksi ohjelmointiparadigmaksi. Taustalla on halu saada ohjelmille esitysmuoto jossa ohjelmien oikeaksitodistaminen olisi helpompaa. Lisäksi funktionaalinen ohjelmointi tarjoaa voimakkaita korkean tason käsitteitä ohjelmien kirjoittamiseen ja ongelmien ratkontaan. 

Funktionaalisen ohjelmoinnin taustalla olevaa teoriaa kutsutaan lambda-laskennaksi. Lambda-laskenta kehitettiin alun perin formalismiksi jonka avulla voi esittää kaikki laskettavissa olevat funktiot. Hyvin pian huomattiin että lambda-laskenta on ilmaisuvoimaltaan yhtäläinen Turingin koneiden kanssa. 

John McCarthy kehitti vuonna 1958 tekoälyyn ja symboliseen laskentaan soveltuvan Lisp-kielen. McCarthy halusi kieleensä funktiot ensimmäisen luokan arvoina, ja sopiva malli tähän löytyi lambda-laskennasta. Lisp ei kuitenkaan varsinaisesti ollut puhdas funktionaalinen ohjelmointikieli, koska se salli tilan. Toinen merkittävä Lispin ominaisuus oli Lisp-koodin esittäminen Lisp-listoina. 

Lispin jälkeen on tullut monia muita kieliä jotka tukevat funktionaalista ohjelmointiparadigmaa. Merkittävimmät näistä lienevät Scheme, Erlang, Scala, ML ja Haskell. Haskell on alun alkaen suunniteltu puhtaaksi ja laiskaksi funktionaaliseksi kieleksi. Haskell on lisäksi vahvasti tyypitetty, monimuotoinen ja tukee tyyppien johtamista. 

Funktionaalisessa ohjelmoinnissa on tyypillistä että funktioita käsitellään ensimmäisen luokan arvoina. Lista on määritelty perustietorakenteena lähes kaikissa funktionaalista ohjelmointia tukevissa kielissä, samoin eri listaoperaatiot. Toisto saavutetaan rekursion avulla. Funktionaalisista ohjelmointikielistä Haskell tukee lausekkeiden laiskaa evaluaatiota, mikä on tehokkaampaa kuin tiukka evaluaatio, ja mahdollistaa päättymättömät tietorakenteet. Funktionaalisen mallin kannalta ongelmallinen siirräntä on toteutettu Haskell-kielessä monadien avulla.  

\newpage

%%\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

\end{document}
