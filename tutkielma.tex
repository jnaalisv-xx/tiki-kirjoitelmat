% rubber: module pdftex
% rubber: path tktl
% rubber: bibtex.stylepath tktl
% rubber: bibtex.path .

\documentclass{tktltiki}
\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\begin{document}
\onehalfspacing

\title{Funktionaalinen ohjelmointi}
\author{Juho Naalisvaara}
\date{\today}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}
\classification{\protect{\ \\
  D.1.1 [Programming Techniques]: Applicative (Functional) Programming, \\
  D.3.2 [Programming Languages]: Language Classifications - \\
  \textit{applicative languages;nonprocedural languages; 
	very high-level languages}, \\
  F.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic - \\ 
	\textit{lambda calculus and related systems}, \\
  K.2 [History of Computing]: Software
}}

\keywords{funktionaalinen ohjelmointi, korkeamman asteen funktiot, laiska evaluaatio}

\begin{abstract}
Funktionaalinen ohjelmointiparadigma ja sen teoreettinen perusta. Miten funktionaalinen ohjelmointiparadigma eroaa imperatiivisesta ohjelmointiparadigmasta. Funktionaalinen ohjelmointikieli Haskell. Funktionaalisen ohjelmoinnin erityispiirteet.
\end{abstract}

\mytableofcontents

\section{Johdanto}

Yleisimm‰t k‰ytˆss‰ olevat ohjelmointikielet perustuvat laskennan malliin, jossa ohjelmalla on \textit{tila} (state), ja t‰t‰ tilaa muokataan ohjelmointikielen tarjoamien lauseiden tai komentojen avulla. T‰ll‰isi‰ ohjelmointikieli‰, kuten Java tai C\#, kutsutaan \textit{imperatiivisiksi} (imperative language). Imperatiivisessa ohjelmoinnissa ohjelmoija kirjoittaa lauseita, jotka muokkaavat ohjelman tilaa tietyss‰ j‰rjestyksess‰. Imperatiivisen ohjelmointiparadigman laskennan mallia kutsutaan \textit{Turingin koneeksi} (Turing machine), kehitt‰j‰ns‰ Alan Turingin mukaan. Imperatiivisen mallin ongelmana voidaan pit‰‰ sit‰ ett‰ ohjelman oikeaksi todistaminen on hyvin hankalaa. Samoin ohjelman kaikkien mahdollisten suorituspolkujen testaaminen on yleens‰ mahdotonta, johtuen ohjelman eri tilojen lukum‰‰r‰st‰.

\textit{Funktionaalinen ohjelmointiparadigma} (functional programming) vastaa n‰ihin haasteisiin tarjoamalla ohjelmointimallin jossa ohjelmilla ei ole tilaa. Tilattomuus helpottaa ohjelman testaamista huomattavasti, koska se v‰hent‰‰ mahdollisten suorituspolkujen m‰‰r‰‰. Funktionaalisten ohjelmien oikeaksi todistaminen on myˆs huomattavasti helpompaa kuin imperatiivisten, johtuen taustalla vaikuttavasta laskennan mallista. Lis‰ksi funktionaaliset ohjelmat ovat yleens‰ lyhyempi‰ kuin niiden imperatiiviset vastineensa, koska funktionaaliset kielet ovat yleens‰ korkeamman tason kieli‰ kuin imperatiiviset.

%% TODO: saisko paremmin?
Funktionaalisen ohjelmoinnin laskennan mallina on funktio, sen matemaattisessa merkityksess‰. Matemaattisilla funktioilla ei ole tilaa eik‰ \textit{sivuvaikutuksia} (side-effects), vaan ne ovat kuvauksia l‰htˆjoukosta (domain) maalijoukkoon (range). Usein myˆs imperatiivisen ohjelmoinnin yhteydess‰ puhutaan funktioista, esimerkiksi C-kieless‰ kaikki suoritettava koodi on funktioissa. N‰m‰ C-kielen funktiot eiv‰t kuitenkaan ole funktioita matemaattisessa merkityksess‰, sill‰ niill‰ voi olla sis‰inen tila, ja ne voivat vaikuttaa funktion ulkoiseen tilaan, esimerkiksi muuttamalla jonkin globaalin muuttujan arvoa. Toisaalta C-kielen funktion laskennan tulos voi myˆs riippua ohjelman tilasta, jolloin funktio ei laske samoilla argumenteilla samaa tulosta joka kutsukerralla.

Funktionaalisen paradigman l‰htˆkohtana on koostaa ohjelma lukuisista pienist‰, helposti testattavista, funktioista. Funktioita voi myˆs v‰litt‰‰ parametreina, tai palauttaa paluuarvoina. Funktionaaliselle ohjelmoinnille tyypillist‰ on runsas listojen ja rekursion k‰yttˆ. Lista onkin useimmissa funktionaalisissa kieliss‰ perustietotyyppi. Koska funktionaalisessa ohjelmoinnissa ei ole tilaa, ei myˆsk‰‰n tilaan perustuvia toistorakenteita, kuten for-lausetta voi k‰ytt‰‰. Toisto saadaankin aikaan rekursiolla.

%% Onko liian syv‰‰ tavaraa johdantoon?
Funktionaalisessa ohjelmoinnissa ohjelmaa suoritetaan evaluoimalla, eli sievent‰m‰ll‰ lausekkeita. Lauseke voi olla arvo, funktio tai funktion sovellus argumenttiinsa. Argumentit ovat lausekkeita, eli arvoja, funktioita tai funktioiden sovelluksia argumentteihinsa. Lausekkeen evaluoinnissa arvot ja funktiot ovat jo normaalimuodossaan, eiv‰tk‰ en‰‰ sievenny yksinkertaisempaan muotoon. Evaluoitaessa funktion sovellusta argumenttiinsa, funktion formaalit parametrit korvataan argumenteilla. Jos tuloksena saatu lauseke on normaalimuotoinen, evaluointi p‰‰ttyy. Muutoin tuloslauseketta sievennet‰‰n kunnes p‰‰st‰‰n lausekkeen normaalimuotoon, jota ei voi en‰‰ sievent‰‰. T‰m‰ normaalimuoto on laskennan tulos.

%% lambda -> lisp
Funktionaalisen ohjelmoinnin laskennan malli on otettu Alonzo Churchin vuonna 1936 kehitt‰m‰st‰ \textit{lambda-laskennasta} (lambda-calculus). Church kehitti lambda-laskennan formalismiksi, jolla m‰‰ritell‰ kaikki laskettavissa olevat funktiot. Vuonna 1960 esiteltiin ensimm‰inen funktionaaliseen ohjelmointiin soveltuva kieli, Lisp (LISt Processing Language) \cite{lisp}. Kielen kehitt‰j‰, John McCarthy, halusi kieleens‰ mahdollisuuden v‰litt‰‰ funktioita argumentteina, ja lambda-kalkyyli tarjosi t‰h‰n sopivan notaation. 

%% lisp -> scheme
Lispin johdannaiset, Scheme ja Common Lisp, ovat edelleen k‰ytˆss‰. Muita funktionaaliseen ohjelmointiin soveltuvia kieli‰ ovat muun muassa, Scala, F\#, Standard ML, Erlang ja Python. Edell‰mainitut kielet eiv‰t kuitenkaan ole puhtaasti funktionaalisia, joko ne sallivat sivuvaikutukset, tai ovat moniparadigmakieli‰. Haskell on sivuvaikutukseton alun alkaen funktionaaliseen ohjelmointiin suunniteltu kieli. 

\newpage
\section{Historiaa}
Funktionaalinen ohjelmointiparadigma on l‰hes yht‰ vanha kuin tietokoneet, ja sen teoreettinen pohja luotiin ennenkuin ensimm‰inen elektroninen tietokone oli n‰hnyt p‰iv‰nvalon. T‰ss‰ kappaleessa kerrotaan lyhyesti lambda-laskennasta, johon funktionaalisen ohjelmoinnin malli pohjautuu, ensimm‰isest‰ funktionaaliseen ohjelmointiin soveltuvasta ohjelmointikielest‰ sek‰ lopuksi mainitaan muutamia suosituimpia nykyisin k‰ytˆss‰ olevia funktionaalisia kieli‰.

%% TODO: osoittautui
%% TODO: taas lambda
\subsection{Lambda-laskenta}
Vuonna 1936 Alonzo Church kehitti lambda-laskennan matemaattisena formalismina, jonka avulla pystyttiin m‰‰rittelem‰‰n kaikki laskettavissa olevat funktiot. H‰nen tarkoituksenaan oli ratkaista \textit{pys‰htymisongelma} (saks. \textit{entscheidungsproblem}). Osoittautui, ett‰ ei voida m‰‰ritell‰ algoritmia jolla laskea kaikki laskettavissa olevat funktiot. Samaan aikaan Alan Turing p‰‰tyi samaan tulokseen omalla laskennan mallillaan, \textit{turing-koneella} (Turing machine) \cite[s.5]{lambda}. Turing osoitti ett‰ h‰nen kehitt‰m‰ns‰ laskennan malli oli ilmaisuvoimaltaan yht‰ voimakas, toisin sanoen m‰‰ritteli saman funktioiden joukon, kuin Churchin lambda-laskenta.
%% TODO: mit‰ osoittautui? aikaj‰rjestys, faktat? "turing osoitti..."

%% TODO: esimerkki‰. selostusta, mit‰ viel‰?, UUSIKS, EI TƒTƒ KUKAAN TAJUU!!!
Lambda-laskennassa on yksi sievennyss‰‰ntˆ, jonka mukaan funktion formaali parametri korvataan sille annetulla argumentilla funktion vartalossa. Funktioita ja niiden sovelluksia sis‰lt‰vi‰ lausekkeita sievennet‰‰n kunnes p‰‰st‰‰n normaalimuotoon, eli lauseketta ei voi en‰‰ sievent‰‰. T‰m‰ normaalimuoto on lambda-laskennan tulos. Lambda-laskenta on hyvin yksinkertainen, mutta ilmaisuvoimainen sievennyss‰‰nnˆstˆ. Lambda-laskenta koostuu \textit{lambda-lausekkeista}, joita ovat \textit{abstraktio} (function abstraction), joka m‰‰rittelee funktion, \textit{sovellus} (application), joka on funktion sovellus argumenttiinsa, tai \textit{muuttuja} (variable). Funktion vartalo on lambda-lauseke, ja funktioilla on vain yksi argumentti. Mik‰li halutaan esimerkiksi kaksiargumenttinen funktio, voidaan m‰‰ritell‰ funktio, joka palauttaa toisen funktion sitoen argumenttinsa palauttamansa funktion vartalossa.

%% TODO: taas lisp
\subsection{Lisp}
Ensimm‰inen funktionaaliseen ohjelmointiin soveltuva kieli oli listojen k‰sittelyyn ja symboliseen laskentaan kehitetty \textit{Lisp} (LISt Processing language). Sen kehitti vuonna 1960 John McCarthy \cite{lisp}. Lisp on toiseksi vanhin korkean tason kieli, Fortranin ollessa vanhin. Lispiss‰, kuten l‰hes kaikissa funktionaalisissa kieliss‰, on perustietorakenteena lista ja alkeisoperaattoreina funktiot, jotka palauttavat listan ensimm‰isen solmun tai listan h‰nn‰n. McCarthy perusti kielens‰ Alonzo Churchin 1932 kehitt‰m‰‰n lambda-kalkyyliin \cite[s.5]{lambda} 

%Lambda-lauseke voi olla \textit{abstraktio} eli funktiom‰‰ritelm‰, joka m‰‰rittelee funktion jolla on yksi argumentti ja vartalo joka on Lambda-lauseke, \textit{sovellus} joka on 

%Lambda-kalkyylissa funktiot esitet‰‰n \textit{lambda-abstraktioina} ja \textit{sovellus} mahdollistaa m‰‰riteltyjen funktioiden soveltamisen. \textit{Muuttujaan} voidaan sitoa mik‰ tahansa lambda-lauseke
% ja lambda-kalkyyli onkin sievennysj‰rjestelm‰ lambda-lausekkeille. Lambda-lauseke koostuu muuttujista, vakioista ja funktion sovelluksista. 

\subsection{Muita funktionaalisiseen ohjelmointiin soveltuvia kieli‰}
Muita funktionaaliseen ohjelmointiin soveltuvia kieli‰ ovat \textit{Scheme} (Lisp-murre), \textit{Standard ML}, \textit{Erlang}, \textit{Haskell}, \textit{Ruby}, \textit{Python} ja \textit{Scala}. N‰ist‰ ainoastaan Haskell on ainostaan funktionaaliseen ohjelmointiin suunniteltu kieli. Muut kielet ovat joko multiparadigmakieli‰ tai mahdollistavat piirteit‰ jotka eiv‰t kuulu funktionaaliseen ohjelmointiin. Esimerkiksi Schemess‰ on \textit{let-lause} jonka avulla voi m‰‰ritell‰ muuttujia. Erlang on Ericssonin kehitt‰m‰ tosiaika-ohjelmointiin soveltuva kieli. Scala on Java-alustalla toimiva kieli.

%% TODO: Haskell 1990 LƒHDE!
%% TODO: Haskell B CURRY LƒHDE!
\section{Haskell}
Funktionaalisten ohjelmointikielten tutkimus oli kovassa nousussa 1980-luvun loppupuolella, jonka seurauksen myˆs funktionaalisten kielten m‰‰r‰ kasvoi voimakkaasti. Hyvin pian tutkijat p‰‰siv‰t yhteisymm‰rrykseen siit‰ ett‰ tarvittiin yleinen standardoitu funktionaalinen ohjelmointikieli. Standardoinnin tuloksena syntyi loogikko Haskell B. Curryn mukaan nimetty Haskell \cite{haskellreport}. Kielen ensimm‰inen versio julkaistiin vuonna 1990. Seuraavina vuosina Haskell kehittyi voimakkaasti, ja 1999 julkaistiin seuraava vakaa standardi, Haskell 98. T‰ss‰ kirjoitelmassa esitetyt esimerkit on kirjoitettu Haskell 98-standardin mukaisesti. Haskell kehittyy edelleen, seuraava versio, eli Haskell', on tulossa 2010.

Haskell on moderni yleisk‰yttˆinen funktionaalinen ohjelmointikieli, ja de facto-standardi funktionaalisten ohjelmointikielten tutkimuksessa. 

%%% LAUSEKKEET,ARVOT,TYYPIT ==================================================================================
\subsection{Lausekkeita, arvoja ja tyyppej‰}
Funktionaalisessa ohjelmoinnissa kaikki laskenta tapahtuu evaluoimalla \textit{lausekkeita} (expression), jolloin tuloksena saadaan \textit{arvoja} (value). Jokaiseen arvoon liittyy \textit{tyyppi} (type). Lausekkeita ovat atomiset arvot kuten kokonaisluku \texttt{7} tai merkki \texttt{'a'}, funktiot kuten \texttt{$\backslash$x->x+1}, totuusarvot kuten \texttt{True}, sek‰ yhdistelm‰tyypit kuten lista \texttt{[1,2,3]} ja pari \texttt{(1, 'a')}. 

Arvoihin liittyvi‰ tyyppej‰ voivat olla esimerkiksi \texttt{Integer} (kokonaisluvut), \texttt{Char} (merkit), \texttt{Integer -> Integer} (funktiot jotka kuvaavat kokonaisluvut kokonaisluvuille), \texttt{Bool} (totuusarvot), \texttt{[Integer]} (kokonaisluvuista koostuva lista) ja \texttt{(Integer, Char)} (kokonaisluvuista ja merkeist‰ koostuvat parit).

Edelliset arvoesimerkit ja niihin liittyv‰t tyypit voidaan merkit‰ seuraavasti:
\begin{verbatim}
                          7 ::  Integer
                        'a' ::  Char
                    [1,2,3] :: [Integer]
                   (1, 'a') :: (Integer, Char)
                    \x->x+1 :: Integer -> Integer
                       True :: Bool
\end{verbatim}
Merkint‰ \texttt{a :: b} tarkoittaa ett‰ lauseke \texttt{a} on tyyppi‰ \texttt{b}. Tyyppien, kuten \texttt{Integer}, nimet tulee kirjoittaa isolla alkukirjaimella, ja arvoa merkitsevien nimien pienell‰.
%%% /LAUSEKKEET,ARVOT,TYYPIT ================================================================================

%%% FUNKTIOT ================================================================================================
\subsection{Funktiot}
Funktiot m‰‰ritell‰‰n Haskellissa yht‰lˆin‰. Esimerkiksi funktio joka ottaa parametrinaan yhden kokonaisluvun ja korottaa sen arvoa yhdell‰, voidaan m‰‰ritell‰ n‰in:
\begin{verbatim}
 inc n = n + 1
\end{verbatim}
Haskellin tyyppij‰rjestelm‰ osaa p‰‰tell‰ lausekkeiden tyypit, mutta lis‰‰m‰ll‰ tyyppiannotaatio voidaan v‰ltt‰‰ virheit‰, ja lis‰t‰ koodin luettavuutta. Funktion tyypin voi merkit‰ tyyppiannotaatiolla n‰in:
\begin{verbatim}
 inc          :: Integer -> Integer
\end{verbatim}
Funktio \texttt{inc} on siis kuvaus kokonaislukujen joukosta kokonaislukujen joukkoon. Funktion m‰‰ritelm‰ voidaan kirjoittaa tyyppiannotaation kanssa seuraavasti:
\begin{verbatim}
 inc          :: Integer -> Integer
 inc n = n + 1
\end{verbatim}
Ehtolausekkeita k‰ytet‰‰n Haskellissa seuraavan esimerkin mukaisesti:
\begin{verbatim}
 boolToInt b = if b then 1 else 0
\end{verbatim}
Seuraava esimerkki havainnollistaa \textit{ehtojen} (guards) k‰yttˆ‰ funktion m‰‰rittelyss‰:
\begin{verbatim}
 boolToInt2 b | b == True = 1
              | otherwise = 0
\end{verbatim}
Ehto on pystyviivan ja yht‰suuruusmerkin (\texttt{=}) v‰liss‰ oleva lauseke, joka on tyyppi‰ \texttt{Bool}. \texttt{otherwise} on synonyymi arvolle \texttt{True}. Ehdot k‰yd‰‰n j‰rjestyksess‰ l‰pi ylh‰‰lt‰ alas. Jos jokin ehdoista evaluoituu todeksi, pys‰ytet‰‰n l‰pik‰ynti ja funktio saa arvoksi yht‰lˆn oikean puolen arvon. \texttt{boolToInt} ja \texttt{boolToInt2}-funktioiden tyyppi on \texttt{Bool -> Integer}.
%%% /FUNKTIOT ==============================================================================================

%%% OPERAATTORIT ==========================================================================================
\subsection{Operaattorit}
Haskell sis‰lt‰‰ kaikki tavanomaiset sis‰merkint‰operaattorit, kuten yhteenlaskun \texttt{+}, miinuslaskun \texttt{-}, jakolaskun \texttt{/}, kertolaskun \texttt{*} sek‰ muita tarpeellisia operaattoreita. Operaattorit saattavat assosioida vasemmalle, kuten edell‰mainitut, tai oikealla, kuten potenssioperaattori \texttt{\^}. Lis‰ksi Haskell tarjoaa kaksi listojen k‰sittelyyn soveltuvaa operaattoria, listakonstruktori \texttt{:}, ja listojen yhdistysoperaattori \texttt{++}. Operaattoreille on m‰‰ritelty normaalit presedenssit, esimerkiksi kertolasku sitoo tiukemmin kuin yhteenlasku. Sis‰merkint‰operaattoreilla on myˆs tyyppi, esimerkiksi kertolaskuoperaattorin tyyppi on \texttt{(Num a) => a -> a -> a}. T‰ss‰ merkint‰ \texttt{Num a =>} tarkoittaa ett‰ kertolaskuoperaattorin argumentit ovat tyyppi‰ \texttt{a} joka toteuttaa tyyppiluokassa \texttt{Num} m‰‰ritellyt funktiot. Haskellin operaattorit eroavat funktioista kahdella tapaa, funktion sovellus argumenttiinsa sitoo tiukemmin kuin operaattorin sovellus argumenttiinsa ja funktioille ei voi m‰‰ritell‰ presedenssi‰.

Funktionaalisissa ohjelmointikieliss‰ kuten Haskellissa, lista on usein m‰‰ritelty alkeistietotyyppin‰. Listaoperaattoreita (\texttt{:}, \texttt{++}) voidaan k‰ytt‰‰ listojen konstruoinnissa seuraavasti:
\begin{verbatim}
 concatenate :: [Integer] -> [Integer] -> [Integer]
 concatenate l1 l2 = l1 ++ l2

 addToList :: Integer -> [Integer] -> [Integer]
 addToList n l = n:l

 empty :: [a] -> Bool
 empty [] = True
 empty _ = False
\end{verbatim}
Operaattori \texttt{++} siis yhdist‰‰ kaksi listaa. Lauseke \texttt{concatenate [1,2] [3,4]} evaluoituu arvoksi \texttt{[1,2,3,4]}. Operaattori \texttt{:} lis‰‰ ensimm‰isen‰ argumenttinaan saamansa kokonaisluvun toisena argumenttina saadun kokonaislukulistan k‰rkeen. Lauseke \texttt{addToList 1 [2,3,4]} evaluoituu arvoksi \texttt{[1,2,3,4]}. Funktio \texttt{empty} testaa listan tyhjyytt‰. Merkint‰ \texttt{[]} tarkoittaa tyhj‰‰ listaa, ja jos funktiolle \texttt{empty} annetaan parametrina tyhj‰ lista, se palautta \texttt{True}. Muussa tapauksessa funktio palauttaa \texttt{False}.  
%%% /OPERAATTORIT ==========================================================================================

%%% UUSIEN TIETOTYYPPIEN MƒƒRITTELY ========================================================================
\subsection{Uusien tietotyyppien m‰‰rittely}
Uusia tyyppej‰ voi m‰‰ritell‰ avainsanan \texttt{data} avulla. Esimerkiksi totuusarvot m‰‰ritell‰‰n n‰in:
\begin{verbatim}
 data Bool         = False
                   | True
\end{verbatim}
Uuden tyypin m‰‰ritelm‰ on yht‰lˆ, jossa yht‰suuruusmerkin vasemmalla puolella annetaan uuden \textit{tyyppikonstruktorin} (type constructor) nimi, ja yht‰suuruusmerkin oikealla puolella annetaan uusien \textit{arvokonstruktorien} (value constructors, data constructors) nimi tai nimet pystyviivalla erotettuina. Merkint‰ tarkoittaa ett‰ arvokonstruktoreilla \texttt{False} ja \texttt{True} voi luoda \texttt{Bool}-tyyppisi‰ arvoja. T‰ss‰ tapauksessa sek‰ tyyppi- ett‰ arvokonstruktorit ovat parametrittomia. \texttt{Bool} on enumeroituva tyyppi, koska se koostuu ‰‰rellisest‰ m‰‰r‰st‰ parametrittomia arvokonstruktoreita. Arvokonstruktorit ovat analogisia Javan konstruktoreiden kanssa. 

%% Listoista
%Funktionaalisissa ohjelmointikieliss‰ kuten Haskellissa, lista on usein m‰‰ritelty alkeistietotyyppin‰. Lista voidaan m‰‰ritell‰ myˆs seuraavasti:
%\begin{verbatim}
%data List a = Nil
%            | Cons a (List a)
%\end{verbatim}
%M‰‰ritelm‰n ensimm‰isen rivi m‰‰rittelee tyyppikonstruktorin \texttt{List a}, jonka parametri \texttt{a} on tyyppimuuttuja. \texttt{Nil} on tyhj‰ arvokonstruktori joka vastaa tyhj‰‰ listaa. Listaan voi sijoittaa mink‰tyyppisi‰ arvoja tahansa, myˆs funktioita. M‰‰ritelm‰n toisella rivill‰ m‰‰ritell‰‰n kaksiparametrinen arvokonstruktori \texttt{Cons}, jonka tyyppi on \texttt{a -> List a -> List a}. Arvokonstruktorin ensimm‰inen parametri on jokin listaan tallennettava arvo, ja toinen parametri on listan h‰nt‰, joka voi olla tyhj‰ tai lista samantyyppisi‰ arvoja. Haskellissa merkint‰ \texttt{[]} tarkoittaa tyhj‰‰ listaa, ja operaattori \texttt{:} on vastaa arvokonstruktori \texttt{Cons}:ia. 

Kokonaislukuja s‰ilˆv‰ bin‰‰ripuu voidaan m‰‰ritell‰ seuraavasti:
\begin{verbatim}
 data BinaryTree   = EmptyTree
                   | BinaryTree Integer BinaryTree BinaryTree 
\end{verbatim}
Nyt tyyppikonstruktori ja toinen arvokonstruktori ovat samannimisi‰. T‰m‰ on mahdollista, koska Haskellissa tyyppikonstruktorit ja arvokonstruktorit asuvat eri nimiavaruuksissa, jolloin ei ole vaaraa niiden sekoittumisesta. \texttt{EmptyTree} on parametriton arvokonstruktori joka luo tyhj‰n puun. Arvokonstruktori \texttt{BinaryTree} ottaa parametreikseen kokonaisluvun ja kaksi tyyppi‰ \texttt{BinaryTree} olevaa bin‰‰ripuuta, joista ensimm‰inen on puun vasen oksa, ja toinen on puun oikea oksa. Arvokonstruktorit ovat oikeastaan funktioita, esimerkiksi t‰ss‰ tapauksessa arvokonstruktori \texttt{BinaryTree}:n tyyppi on \texttt{Integer -> BinaryTree -> BinaryTree -> BinaryTree}. Koska tyypin \texttt{BinaryTree} toisessa arvokonstruktorissa on kaksi \texttt{BinaryTree} tyyppist‰ parametria, on \texttt{BinaryTree} rekursiivinen tietotyyppi. Muotoa \texttt{a -> b -> c} oleva funktion tyyppimerkint‰ tarkoittaa ett‰ funktiolla on kaksi parametria tyyppi‰ \texttt{a} ja \texttt{b}, ja lopuksi funktio palauttaa tyyppi \texttt{c} olevan arvon. Arvokonstruktorien kuten \texttt{True} ja \texttt{BinaryTree} nimet tulee kirjoittaa isolla alkukirjaimella.
%% Parametrisoitu monimuotoisuus myˆhemmin, listojen yhteydess‰
%%% / UUSIEN TIETOTYYPPIEN MƒƒRITTELY ======================================================================

\subsection{Tyyppisynonyymit}
Haskell tarjoaa yksinkertaisen rakenteen jolla m‰‰ritell‰ \texttt{tyyppisynonyymeja} (type synonyms). Esimerkiksi Haskell 98 -standardissa \texttt{String} on m‰‰ritelty tyyppisynonyymiksi merkkilistalle (\texttt{[Char]}). Tyyppisynonyymeja m‰‰ritell‰‰n seuraavan esimerkin mukaan.
\begin{verbatim}
type String = [Char]

type Name = String
type Address = String
data Person = (Name, Address)
\end{verbatim}
\texttt{Person} on tyyppi joka koostuu nimi-osoite-parista. Tyyppisynonyymit parantavat l‰hdekoodin luettavuutta.

%%% TYYPPILUOKAT ===========================================================================================
\subsection{Tyyppiluokat}
\textit{Tyyppiluokka} (type class) esittelee joukon funktioita, jotka kyseisen tyyppiluokan toteuttavien tyyppien tulee toteuttaa. Kyseess‰ on siis Javan rajapintoja vastaava ominaisuus. Merkint‰ \texttt{(TyyppiLuokka a) => a} tarkoittaa ett‰ tyyppi \texttt{a} toteuttaa tyyppiluokassa \texttt{TyyppiLuokka} esitellyt funktiot. Esimerkiksi yht‰suuruusoperaattorin (\textit{==}) tyyppimerkint‰ \texttt{(==) :: (Eq a) => a -> a -> Bool} tarkoittaa ett‰ yht‰suuruusoperaatorilla voidaan verrata kaikkia niit‰ tyyppej‰ \texttt{a}, jotka toteuttavat tyyppiluokan \texttt{Eq}, ja yht‰suuruusoperaattorin paluuarvo on tyyppi‰ \texttt{Bool}. 

%Jos esimerkiksi halutaan kirjoittaa funktio joka tutkii onko parametrina annettu alkio toisena parametrina annetun listan j‰sen, se voidaan kirjoittaa n‰in:
%\begin{verbatim}
%x 'elem' []     = False
%x 'elem' (y:ys) = x==y || (x 'elem' ys)
%\end{verbatim}
%Merkint‰ \texttt{[]} tarkoittaa tyhj‰‰ listaa. Kirjoittamalla heittomerkit funktion nimen ymp‰rille, sit‰ voidaan k‰ytt‰‰ sis‰merkint‰tyyliin (infix). M‰‰ritelm‰n ensimm‰inen rivi tarkoittaa ett‰ jos toinen parametri on tyhj‰ lista, ei haluttu alkio voi lˆyty‰ sielt‰ ja funktio evaluoituu ep‰todeksi. Toinen rivi tarkoittaa ett‰, jos alkio \texttt{x} on yht‰suuri kuin listan ensimm‰inen alkio \texttt{y}, palautetaan tosi, muutoi
%% rekursio ei viel‰ k‰sitelty....

Tyyppiluokka \texttt{Eq} m‰‰ritell‰‰n n‰in:
\begin{verbatim}
class Eq a where
	(==)	:: a -> a -> Bool
\end{verbatim}
T‰ss‰ siis \texttt{Eq} on tyyppiluokan nimi, ja yht‰suuruusoperaattori \texttt{==} on ainoa tyyppiluokassa m‰‰ritelty operaattori.

Jotta yht‰suuruusoperaattoria voitaisiin k‰ytt‰‰ esimerkiksi liukulukujen (\texttt{Float}) vertailuun, tulee tyypin \texttt{Float} toteuttaa tyyppiluokan \texttt{Eq} esittelem‰t operaattori ja funktiot. 
\begin{verbatim}
instance Eq Float where
	x == y 		= x 'floatEq' y
\end{verbatim}
T‰ss‰ \texttt{floatEq} on alkeisfunktio joka vertaa kahden liukuluvun yht‰suuruutta. Laittamalla funktio heittomerkkien v‰liin sit‰ voidaan k‰ytt‰‰ sis‰merkint‰tyyliin. 

%%% /TYYPPILUOKAT ===========================================================================================

%% FUNKTIONAALISEN OHJELMOINNIN ERITYISPIIRTEITƒ
\section{Funktionaalisen ohjelmoinnin erityispiirteit‰}
T‰ss‰ kappaleessa esitell‰‰n funktionaalisen ohjelmointityylin k‰sitteit‰ ja ominaisuuksia esimerkkien kera. Kaikki esimerkit on kirjoitettu Haskell 98 -standardin mukaisesti. Funktionaalisen ohjelmoinnin piirteit‰ verrataan usein \textit{imperatiiviseen ohjelmointiin} (imperative programming). Imperatiivisella ohjelmoinnilla tarkoitetaan yleisint‰ olevaa ohjelmointitapaa, jossa laskentaa simuloidaan muuttamalla ohjelman tilaa (state), eli muuttujien arvoja, tietyss‰ j‰rjestyksess‰ suoritetuilla lauseilla. T‰ll‰isi‰ ohjelmointikieli‰ ovat mm. C, C++, Java ja Pascal. Imperatiivinen ohjelmointi siis kattaa proseduraalisen ja olio-ohjelmoinnin. 

\subsection{Hahmontunnistus}
\textit{Hahmontunnistus} (pattern matching, kuuluu olennaisesti nykyaikaisiin funktionaalisiin kieliin \cite[s. 388]{Hudak89}. Funktio voidaan m‰‰ritell‰ eri hahmoina, joita vastaan lausekketta sitten yritet‰‰n tunnistaa. Esimerkiksi kaksiparametriset loogiset konnektiivit \texttt{or} ja \texttt{and} voidaan m‰‰ritell‰ eri hahmojen avulla seuraavasti:
\begin{verbatim}
 or True _ = True
 or _ True = True
 or _ _    = False

 and True True = True
 and _ _ = False
\end{verbatim}
Funktion \texttt{or} m‰‰ritelm‰n ensimm‰in rivi sis‰lt‰‰ hahmon \texttt{True \_}, joka tarkoittaa tapausta jossa funktion ensimm‰inen argumentti on tosi. Toisen argumentin arvolla ei t‰llˆin ole v‰li‰ ja lauseke evaluoituu todeksi. M‰‰ritelm‰n toisen rivin hahmo \texttt{\_ True} taas vastaa tapausta jossa toinen argumentti on tosi, jolloin ensimm‰isen argumentin arvolla ei ole v‰li‰ ja lauseke evaluoituu todeksi. Funktion \texttt{or} m‰‰ritelm‰n kolmannen yht‰lˆn hahmo \texttt{\_ \_} sopii kaikkkiin mahdollisiin parametriyhdistelmiin. Koska t‰ss‰ vaiheessa on jo k‰yty l‰pi vaihtoehdot joissa ensimm‰inen, toinen tai molemmat argumentit olisivat tosia, saadaan t‰ll‰ yht‰lˆll‰ kiinni vain tapaukset joissa molemmat argumentit ovat ep‰tosia. Alaviiva (\texttt{\_}) sopii mihin tahansa hahmoon. Molemmat funktiot ovat tyyppi‰ \texttt{Bool -> Bool -> Bool}

Funktio \texttt{empty}, joka tutkii onko parametrina annettu bin‰‰ripuu tyhj‰, voidaan kirjoittaa n‰in:
\begin{verbatim}
 empty EmptyTree = True
 empty _         = False
\end{verbatim}
Funktion tyyppi on \texttt{BinaryTree -> Bool}.

Hahmontunnistusta k‰ytet‰‰n usein listojen kanssa. 
\begin{verbatim}
 head (x:_) = x

 tail (_:xs) = xs
\end{verbatim}
Funktio \texttt{head} palauttaa listan ensimm‰isen alkion. Hahmo \texttt{(x:xs)} vastaa listaa jonka ensimm‰inen alkio on \texttt{x}, ja lista loppuosa on \texttt{xs}. Funktio \texttt{tail} taas palauttaa listan loppuosan, siis argumenttina annetun listan ilman ensimm‰ist‰ alkiotaan. 

\subsection{Puhtaat funktiot ja sivuvaikutuksettomuus}
%% SIVUVAIKUTUKSET
Funktiolla sanotaan olevan \textit{sivuvaikutuksia} (side effects) jos se muuttaa ohjelman tilaa tai vaikuttaa ulkomaailmaan muuten kuin paluuarvonsa kautta \cite[s.238]{scott}. Imperatiivisessa ohjelmoinnissa ohjelman tila on sen paikallisten ja globaalien muuttujien arvo tiettyn‰ hetken‰, ja kaikki ohjelmointi, miss‰ muutetaan kyseisten muuttujien arvoa on sivuvaikutuksellista ohjelmointia. Imperatiivinen ohjelmointityyli perustuu nimenomaan ohjelman tilan muuttamiseen. Kun imperaativisessa ohjelmoinnissa lause \texttt{nimi = arvo} tarkoittaa arvon sijoittamista johonkin muistipaikkaan, niin funktionaalisessa ohjelmassa vastaava merkint‰ tarkoittaa ett‰ \texttt{nimi} on lyhennysmerkint‰ arvolle.  


%Imperatiivisessa ohjelmassa kyseist‰ arvoa ei kuitenkaan voi jokaisessa sen esiintymiskohdassa korvata sen sijoituspaikan nimell‰, koska sijoituspaikkaan on voitu kirjoittaa uusi arvo. Puhtaassa funktionaalisessa ohjelmoinnissa taas \texttt{nimi} ja \texttt{arvo} merkitsev‰t samaa asiaa joten ne 

%% nimi = arvo WTF!!!

%%, eik‰ arvon sijoittamista johonkin muistipaikkaan, kuten imperatiivisessa ohjelmoinnissa.
%% ohjelmoinnissa muuttujaa ajatellaan yleens‰ muistipaikan nimen‰, matematiikassa arvon nimen‰
%% fp:ss‰ ei sijoituslauseita, vaan merkintˆj‰ x=y mitk‰ tarkoittavat t‰m‰(y) on lyhennys tuolle(x)
%% t‰m‰ nimi on lyhennysmerkint‰ tuolle arvolle nimi= arvo
%% Imperatiivinen ohjelmointi on sarja j‰rjestettyj‰ muutoksia ohjelman muuttujiin. jokainen muutos implikoi tilanvaihdosta

%% PUHTAAT FUNKTIOT
\textit{Puhtaat funktiot} (pure functions) ovat funktioita matemaattisessa merkityksess‰. Ohjelmoinnista puhuttaessa saatetaan funktioiksi kutsua jopa aliohjelmia joiden laskennan tulos riippuu jostain globaalista muuttujasta, jolloin saattaa p‰te‰ \textit{f(x) $\ne$ f(x)} eri kutsuhetkin‰. Matemaattisilla funktioilla ei ole tilaa, eik‰ sivuvaikutuksia. Matemaattiset funktiot ovat kuvauksia l‰htˆjoukosta (domain) maalijoukkoon (range), ja ne palauttavat samoilla argumenteilla aina saman paluuarvon. T‰st‰ seuraa ett‰ funktiokutsu voidaan korvata sen laskennan tuloksella, ja toisinp‰in. T‰t‰ ominaisuutta kutsutaan \textit{viittausten l‰pikuultavuudeksi} (referential transparency). Imperatiivisessa ohjelmassa t‰m‰ ei v‰ltt‰m‰tt‰ p‰de koska laskennan tulos voi riippua ulkopuolisten muuttujien arvoista jolloin funktio laskee eri tuloksen eri kutsukerroilla. Toisaalta jokin toinen funktio voi kirjoittaa muuttujaan johon on tallennettu funktion paluuarvo ja n‰in funktiokutsua ei voi korvata muuttujalla johon on sijoitettu sen laskennan tulos. Viittausten l‰pikuultavuus helpottaa suuresti ohjelmien oikeellisuuden todistamista \cite[s.362]{Hudak89}.

Viittausten l‰pikuultavuus antaa k‰‰nt‰j‰lle mahdollisuuden korvata monta kertaa ohjelmassa esiintyv‰ lauseke sen arvolla, jolloin lausekkeen arvoa ei tarvitse laskea kuin kerran.
%% TODO: salliiko alkuper‰inen lisp sivuvaikutukset

Funktionaalisessa ohjelmoinnissa ohjelma koostetaan puhtaista funktiosta, joilla ei siis ole tilaa eik‰ sivuvaikutuksia. N‰in funktionaalinen ohjelmointi on tila- ja sivuvaikutuksetonta. Jotkin kielet, kuten Lisp ja sen johdannaiset, sallivat sivuvaikutukset joten ne eiv‰t ole puhtaita funktionaalisia kieli‰, vaan pikemminkin hybridikieli‰ joissa on tuki funktionaaliselle ohjelmoinnille. Tilattomuudesta seuraa ett‰ muuttujien arvoja ei voi muuttaa niiden luonnin j‰lkeen. 
%% TODO: Scheme tarjoaa let-lauseen??? SICP
%% TODO: sivuvaikutusten salliminen
%% TODO: t‰ss‰ kirjoitelmassa muuttuja ei ole kuin imperatiivisessa

Sivuvaikutuksettomuudella on sek‰ myˆnteisi‰ ett‰ kielteisi‰ seurauksia. Koska funktionaalisessa ohjelmoinnissa ei muokata tilaa, ei myˆsk‰‰n tietorakenteita pysty muokkaamaan niiden luonnin j‰lkeen, vaan esimerkiksi poistettaessa listasta alkio, luodaan uusi lista vanhan listan kopiona ilman poistettavaa alkiota. Suuria tietorakenteita kuten tietokantoja ei voida toteuttaa tehokkasti ilman sivuvaikutuksia. Jos esimerkiksi halutaan muuttaa yhden rivin yhden sarakkeen arvo tietokannassa jossa on miljoonia rivej‰, tulisi muutoksen tekev‰n funktion palauttaa kokonaan uusi tietokanta. Lis‰ksi siirr‰nt‰, syˆttˆ ja tulostus, on luonteeltaan sivuvaikutuksellista. Siirr‰nt‰‰n tosin on kehitetty elegantteja funktionaalisia ratkaisuja. 
%%(TODO: l‰hde, Haskell:n stream ja monad io),tietorakenteista, optimoiva k‰‰nt‰j‰?P
%% TODO: yll‰ ja allaoleva lukijan mielest‰ ristiriitaisia.
Sivuvaikutukseton ohjelmointi ei siis sovi kaikkeen. Sivuvaikutuksettomuudesta kuitenkin seuraa ett‰ funktioiden suoritus voidaan huoletta rinnakkaistaa ja ohjelmien tuotantokustannukset laskevat koska ohjelmia on helpompi laatia, korjata ja yll‰pit‰‰ \cite[s.527]{scott}.
%TODO: jotain muuta sivuvaikutuksettomuudesta? Tietorakenteen ja sivuvaikutukset? Funktionaaliset tietorakenteet? sivuvaikutusten parempi m‰‰ritelm‰

%% TODO: Toinen virke palaa ensimm‰iseen virkkeeseen....
%% FUNKTIOT ENSIMMƒISEN LUOKAN ARVOINA
\subsection{Funktiot ensimm‰isen luokan arvoina} 
\textit{Ensimm‰isen luokan arvo} (first class value) voidaan v‰litt‰‰ parametrina, palauttaa funktion paluuarvona tai luoda suoritusaikana \cite[s.526]{scott}. Funktionaalisessa ohjelmoinnissa funktiot ovat ensimm‰isen luokan arvoja, kun taas imperatiivisessa ohjelmoinnissa funktiot ovat yleens‰ toisen luokan arvoja, eik‰ niit‰ ei voi v‰litt‰‰ parametreina, palauttaa paluuarvoina tai luoda suoritusaikana. Jotkut imperatiiviset kielet kuten C tukevat funktio-osoittimien v‰litt‰mist‰ parametreina. Funktioita ei C:ss‰ kuitenkaan voi luoda suoritusaikana jolloin ne eiv‰t ole ensimm‰isen luokan arvoja. Oliokielist‰ SmallTalk tukee funktioita ensimm‰isen luokan arvoina. Yleisesti k‰ytˆss‰ olevissa kieliss‰ alkeistyyppiset arvot kuten kokonaisluvut, liukuluvut, merkit, merkkijonot ja oliot ovat ensimm‰isen luokan arvoja. 

%% TODO: taitaa olla v‰h‰n p‰in vittua!!
Koska ensimm‰isen luokan arvoja voi luoda ohjelmalohkojen sis‰ll‰, voidaan m‰‰ritell‰ funktio, jonka m‰‰rittelyss‰ k‰ytet‰‰n sen m‰‰rittelylohkossa n‰kyvi‰ muuttujia. Funktio voidaan edelleen v‰litt‰‰ parametrina toiselle funktiolle jolloin funktion k‰ytt‰m‰t muuttujat ovat n‰kyvyysalueensa ulkopuolella, ja niit‰ ei voi vapauttaa muistinhallinnan toimesta, kun funktion m‰‰rittelylohkon k‰ytt‰m‰ muisti vapautetaan. Funktiota, jonka m‰‰rittelyss‰ n‰in k‰ytet‰‰n m‰‰rittelylohkonsa muuttujia, kutsutaan \textit{sulkeumaksi} (closure).
%% Sulkeumilla voidaan toteuttaa tila?

%% KORKEAMMAN KERTALUVUN FUNKTIOT
\subsection{Korkeamman kertaluvun funktiot}
\textit{Korkeamman kertaluvun funktioiksi} (higher order functions, functional forms) kutsutaan funktioita jotka ottavat parametrinaan toisen funktion, tai palauttavat paluuarvonaan funktion \cite[s. 546]{scott}. Yksi yleisimpi‰ tapoja k‰ytt‰‰ korkeamman kertaluvun funktioita on rakentaa niiden avulla uusia funktioita. Esimerkiksi Haskell-kielen \textit{map}-funktio ottaa parametrinaan funktion ja listan, ja k‰y listan rekursiivisesti l‰pi soveltaen parametrinaan saamaa funktiota jokaiselle listan alkiolle. 

M‰‰ritell‰‰n funktio \texttt{twice} siten ett‰ se soveltaa parametrina saamaansa funktiota toisena parametrina saamaansa arvoon. 
\begin{verbatim}
 twice f n = f (f n)
\end{verbatim}
Haskell osaa p‰‰tell‰ funktion tyypiksi \texttt{(t -> t) -> t -> t}. Nyt lauseke \texttt{twice inc 5} evaluoituu ensin muotoon \texttt{inc (inc 5)} ja sitten muotoon \texttt{inc 6} ja lopuksi laskennan tuloksena saadaan \texttt{7}.

%% TODO: silmukka pois, for,while,loop on toistoa, rekursio rekursiota, toisto saavutetaan rekursiolla
\subsection{Rekursio}
Imperatiivisessa ohjelmoinnissa toisto saadaan aikaan \texttt{for}-, \texttt{while}- tai \texttt{loop}-lauseilla. Yleisess‰ tapauksess n‰m‰ lauseet tutkivat jonkin muuttujan tilaa, ja sen perusteella p‰‰tt‰v‰t‰ suoritetaanko niihin liitetty koodilohko uudestaan vai ei. Funktionaalisessa ohjelmoinnissa toisto saadaan aikaan rekursiolla. Klassinen esimerkki rekursiosta on kertomafunktio:
\begin{verbatim}
 factorial :: Integer -> Integer
 factorial 0 = 1
 factorial n | n > 0 = n * factorial (n-1)
             | otherwise = -1
\end{verbatim}
Funktio \texttt{factorial} siis kuvaa kokonaislukujen joukon kokonaisluvuille. Funktion sovellus nollaan evaluoituu ykkˆseksi. Jos funktiolle annettu parametri on suurempi kuin nolla, kutsutaan rekursiivisesti \texttt{factorial}-funktiota jotta saadaan luvun \texttt{n-1} kertoma. Nollaa pienemmille luvuille kertomaa ei ole m‰‰ritelty. Funktio \texttt{factorial} on m‰‰ritelty hahmontunnistuksen avulla, ensimm‰isess‰ yht‰lˆss‰ hahmo johon argumenttia sovitetaan on \texttt{0}, ja toisessa yht‰lˆss‰ \texttt{n} (johon sopii kaikki kokonaisluvut).

Listat ovat funktionaalisissa kieliss‰ t‰rkeit‰ koska niill‰ on luonnollinen rekursiivinen m‰‰ritelm‰. Lista voidaan m‰‰ritell‰ vaikkapa n‰in:
\begin{verbatim}
 data List a = Nil
             | Cons a (List a)
\end{verbatim}
T‰ss‰ \texttt{Nil} on parametriton arvokonstruktori jolla luodaan tyhj‰ lista. Haskellissa vastaava parametriton arvokonstruktori on \texttt{[]}. \texttt{Cons a (List a)} on kaksiparametrinen arvokonstruktori joka luo uuden listan. Haskelin vastaava arvokonstruktori on sis‰merkint‰operaattori \texttt{:}. 

Allaolevassa esimerkiss‰ on kolme eri tapaa merkit‰ lista jolla on alkiot \texttt{1}, \texttt{2} ja \texttt{3}. Ensimm‰isen rivin esimerkki on oman m‰‰ritelm‰mme mukainen lista. Keskimm‰inen lista on Haskellin standardi tapa merkit‰ lista. Kolmas esimerkki on syntaktista sokeria keskimm‰iselle merkinn‰lle. 
\begin{verbatim}
 Cons 1 (Cons 2 (Cons 3 Nil))
 1 :  (2 : (3 : []))
 [1,2,3]
\end{verbatim}
Funktio \texttt{length} joka laskee listan pituuden voidaan m‰‰ritell‰ seuraavasti:
\begin{verbatim}
 length [] = 0
 length (x:xs) = 1 + (length xs)
\end{verbatim}
Mik‰li funktion argumenttina on tyhj‰ lista, evaluoituu lauseke arvoon \texttt{0}. Jos argumenttina olevassa listassa on v‰hint‰‰n yksi alkio, evaluoituu funktion paluuarvoksi listan loppuosan pituus lis‰ttyn‰ yhdell‰.

Esimerkiksi lauseke \texttt{length [4,5,1,8,3]} evaluoituu seuraavasti:
\begin{verbatim}
 length [4,5,1,8,3]
 1 + (length [5,1,8,3])
 1 + (1 + (length [1,8,3]))
 1 + (1 + (1+ (length [8,3])))
 1 + (1 + (1+ (1+ (length [3]))))
 1 + (1 + (1+ (1+ (1 + (length [])))))
 1 + (1 + (1+ (1+ (1 + (0)))))
 1 + (1 + (1+ (1+ (1))))
 1 + (1 + (1+ (2)))
 1 + (1 + (3))
 1 + (4)
 5
\end{verbatim}
Laskennan tuloksena on siis \texttt{5}.

Yleinen listojen kanssa k‰ytetty funktio on \texttt{map}, joka soveltaa ensimm‰isen‰ argumenttinaan saamaansa funktiota toisena argumenttina saamansa listan jokaiselle alkiolle. Funktion tyyppi on \texttt{(a -> b) -> [a] -> [b]}. Funktio \texttt{map} voidaan m‰‰ritell‰ n‰in:
\begin{verbatim}
 map _ []     = []
 map f (x:xs) = f x : map f xs 
\end{verbatim}
Lauseke \texttt{map inc [0,1,2]} evaluoituu n‰in:
\begin{verbatim}
 map inc [0,1,2]
 inc 0 : map inc [1,2]
 inc 0 : inc 1 : map inc [2]
 inc 0 : inc 1 : inc 2 : map inc []
 inc 0 : inc 1 : inc 2 : []
 inc 0 : inc 1 : 3 : []
 inc 0 : inc 1 : [3]
 inc 0 : 2 : [3]
 inc 0 : [2,3]
 1 : [2,3]
 [1,2,3]
\end{verbatim}
T‰ss‰ \texttt{:} on sis‰merkint‰operaattori, jolla luodaan uusi lista. Operaattori \texttt{:} on tyyppi‰ \texttt{a -> [a] -> [a]}.

%% TODO: FOLD!!!

Toinen yleinen listojen k‰sittelyyn soveltuva on \texttt{foldl}.

Esimerkiksi kertoma voidaan m‰‰ritell‰ funktion \texttt{foldl} avulla n‰in:
\begin{verbatim}
 factorial2 0 = 1
 factorial2 n  = foldr (*) 1 [1..n]
 factorial2 _ = -1
\end{verbatim}


\subsection{Evaluointij‰rjestys}
Funktionaalisten ohjelmien evaluoimiseen on vakiintunut kaksi tapaa. \textit{Tiukassa evaluaatiossa} (strict evaluation) lausekkeet, erityisesti funktioiden argumentit, evaluoidaan aina, oli siihen tarvetta tai ei. Tiukan mallin avulla voidaan k‰‰nnˆsaikana tunnistaa p‰‰ttym‰ttˆm‰t lausekkeet, toisin sanoen lausekkeet jotka eiv‰t evaluoidu, vaan hajaantuvat. Haittapuolena pit‰‰ ohjelmien m‰‰rittelyss‰ olla tarkkana, sill‰ v‰‰r‰ m‰‰rittelyj‰rjestys voi johtaa siihen ett‰ sin‰ns‰ validi ohjelma ei k‰‰nny. 
%% TODO: ep‰m‰‰r‰inen
Tiukan evaluaation vastakohta on \textit{laiska evaluaatio} (lazy evaluation), jossa lausekkeiden arvot evaluoidaan vasta kun niit‰ tarvitaan. Esimerkiksi, jos listan ensimm‰isen alkion palauttavalle funktiolle annetaan argumenttina p‰‰ttym‰tˆn lista niin tiukkaa evaluaatiota k‰ytt‰v‰ ohjelma ei edes k‰‰nny kun taas laiskaa evaluaatiota k‰ytt‰v‰ ohjelma evaluoi listasta vain sen ensimm‰isen alkion. Funktionaalinen ohjelmointikieli on laiska, jos se evaluoi lausekkeensa laiskasti. Yleisesti ottaen laiskat kielet ovat nopeampia kuin tiukat, johtuen siit‰ ett‰ ne eiv‰t yrit‰ evaluoida kaikkia lausekkeita.
%% TODO: funktionaalisen ohjelmointikielen laiskuus, l‰hde!!
%% TODO: hajaantuvat? selitys 

Yleisesti imperatiiviset kielet k‰ytt‰v‰t tiukkaa evaluaatiota. Funktionaaliseen ohjelmointiin sopivista kielist‰ Lisp ja sen johdannaiset k‰ytt‰v‰t tiukkaa evaluaatiota, tosin Schemeen on lis‰tty tuki laiskalle evaluaatiolle. Haskell sen sijaan k‰ytt‰‰ laiskaa evaluaatiota. 
%% TODO: scheme l‰hde

%\textit{Laiska evaluatio} (engl. \textit{lazy evaluation, non-strict evaluation}), sivuvaikutuksettomuuden seuraus, mit‰ siit‰ seuraa, tiukka evaluaatio, laiskat tietorakenteet, haskell ja lisp, \textit{laiska funktio} 

\subsection{Tyypitys ja monimuotoisuus funktionaalisissa kieliss‰}

\textit{Dynaaminen tyypitys} (dynamic typing) tarkoittaa tyyppij‰rjestelm‰‰, jossa tyypit tarkastetaan vasta suoritusaikana \cite[s.310]{scott}. Esimerkiksi useat skripti-kielet ja Lisp ovat dynaamisesti tyypitettyj‰. Dynaaminen tyypitys tarkoittaa ett‰ mahdollisia tyyppivirheit‰ ei havaita viel‰ k‰‰nnˆsaikana, vaan vasta suoritusaikana. Lis‰ksi suoritusaikainen tyyppitarkastus lis‰‰ ohjelman resurssivaatimuksia.
%% TODO: C on staattisesti ja heikosti tyypitetty kieli!!

Ohjelmointikielen sanotaan olevan \textit{vahvasti tyypitetty} (strongly typed) \cite[s.309]{scott}, jos se kielt‰‰ operaattorin tai funktion sovelluksen tyypille, jos funktio tai operaattori ei tue kyseist‰ tyyppi‰. Vahva tyypitys ei myˆsk‰‰n salli tyyppien muuntamista toiseksi (type casting). Ohjelmointikielen sanotaan olevan \textit{staattisesti tyypitetty} \cite[s.309]{scott}, jos  tyyppien tarkastus voidaan tehd‰ k‰‰nnˆsaikana. Funktionaalisista ohjelmointikielist‰ Haskell on staattisesti ja vahvasti tyypitetty. Imperatiivisista ohjelmointikielist‰ muun muassa Java ja C++ ovat staattisesti tyypitettyj‰. Staattinen tyypitys auttaa ohjelmoijaa havaitsemaan tyyppivirheet k‰‰nnˆsaikana.
 
%% TYYPPIEN PƒƒTTELEMINEN
\textit{Tyypin p‰‰tteleminen} (type inference), tarkoittaa sit‰, ett‰ lausekkeen tyyppi voidaan johtaa lausekkeen k‰yttˆymp‰ristˆst‰ tai joistain lausekkeen osista \cite[s.308]{scott}. Useat dynaamisesti tyypitetyt skriptikielet johtavat lausekkeiden tyypit suoritusaikana. Tyyppien johtaminen on yleisesti tuettua funktionaalisissa ohjelmointikieliss‰. N‰in esimerkiksi Haskell-funktion m‰‰rittelyst‰ voidaan j‰tt‰‰ parametrien tyypitys pois. Esimerkiksi aikaisemmin esitelty \texttt{inc}-funktio voidaan m‰‰ritell‰ ilman tyyppiannotaatiota:
\begin{verbatim}
  inc n = n + 1
\end{verbatim}
Haskell k‰‰nt‰j‰ tai tulkki osaa p‰‰tell‰ funktion tyypiksi \texttt{Integer -> Integer} koska funktion m‰‰ritelm‰ss‰ yht‰lˆn oikealla puolella sovelletaan \texttt{+}-operaattoria kokonaislukuun.

%% MONIMUOTOISUUS
\textit{Monimuotoisuus} (polymorphism) tarkoittaa sit‰ ett‰ yksi ohjelmalohko, funktio tai kokonainen ohjelma voidaan suorittaa monilla eri tyypeill‰ \cite[s.309]{scott}. Oliokielist‰ puhuttaessa monimuotoisuutta on kahdenlaista, geneerist‰ eli parametrista monimuotoisuutta joka mahdollistaa luokkien m‰‰rittelyn tyyppiparametrien kanssa. Toinen oliokieliss‰ esiintyv‰ monimuotoisuuden muoto on alityypin monimuotoisuus, eli perint‰‰n perustuva monimuotoisuus. Funktionaalisissa ohjelmointikieliss‰ on parametrinen monimuotoisuus yleist‰. Alla parametrisesta monimuotoisuudesta esimerkkin‰ funktio \texttt{square}. 
\begin{verbatim}
  square :: (Num a) => a -> a 
  square n = n * n
\end{verbatim}
Funktion tyyppiannotaatiossa on tyyppimuuttuja \texttt{a} joka kertoo ett‰ funktio on monimuotoinen. Lis‰ksi tyyppiannotaatiosta n‰kee ett‰ funktio on m‰‰ritelty kaikille tyypeille \texttt{a} jotka toteuttavat tyyppiluokan \texttt{Num} esittelem‰t funktiot, joihin kertolaskuoperaattori kuuluu.

%% oikeastaan tuo on ad hoc (overloading)monimuotoisuutta, 

 Funktionaalisissa kieliss‰ monimuotoisuus on t‰rke‰ ominaisuus, koska se sallii funktioiden k‰ytˆn mahdollisimman monentyyppisill‰ parametreilla. Lisp ja sen johdannaiset ovat dynaamisesti tyypitettyj‰, ja siten luonnostaan monimuotoisia. Koska Haskell-funktioiden parametrien tyyppi‰ ei tarvitse m‰‰ritell‰, saavuttaa Haskell monimuotoisuuden tyyppien johtamisen kautta. Esimerkiksi listoja k‰sittelev‰t funktiot ovat monimuotoisia. Yleens‰ ne eiv‰t edes tied‰ mit‰ tyyppi‰ listan alkiot ovat, koska ne ovat kiinnostuneita vain listan rakenteesta.
%% TODO: kahdenlaista monimuotoisuutta, parametrista ja ajonaikaisesta sidonnasta johtuvaa (??)

%% TODO: abstrakti tietotyyppi
%% TODO: Haskell-kielen tyyppij‰rjestelm‰
%% FUNKTIONAALINEN SIIRRƒNTƒ
\subsection{Funktionaalinen siirr‰nt‰}
Siirr‰nt‰ on sivuvaikutuksellisen luonteensa vuoksi ongelmallinen funktionaalisille ohjelmointikielille. Puhtaissa funktionaalisissa ohjelmointikieliss‰h‰n funktiot palauttavat samoilla argumenteilla aina saman paluuarvon. K‰ytt‰j‰lt‰ syˆtteen lukeva \texttt{read}-funktiohan taas palauttaa k‰ytt‰j‰n syˆtt‰m‰n merkin tai merkkijonon, jolloin funktion paluuarvo vaihtelee kutsukerrasta toiseen.

\textit{Sekvenssointi} (sequencing) tarkoittaa ohjelmointikielen lauseiden suorittamista j‰rjestyksess‰. Funktionaalisissa ohjelmointikieliss‰ lausekkeiden evaluointij‰rjestyksell‰ ei ole v‰li‰. Siirr‰nt‰‰ taas ei voi toteuttaa ilman ett‰ voidaan m‰‰r‰t‰ toimintojen j‰rjestys.

%% TODO: t‰m‰ kappale paremmin!!!
Haskell toteuttaa siirr‰nn‰n \textit{monadien} (monad) avulla. Monadi on on abstrakti tietotyyppi joka tukee sekvenssoinnin k‰sitett‰. Haskellin siirr‰nt‰monadin arvot ovat \textit{toimintoja} (action), jotka ohjelmoija voi pakottaa suoritettavaksi tietyss‰ j‰rjestyksess‰ \cite[s.543]{scott}. Toiminnot ovat funktionaalisesta siirr‰nn‰st‰ puhuttaessa erilaisia luku- tai kirjoitustoimintoja. Haskellin siirr‰nt‰monadin funktiot joko palauttavat tai ottavat parametreikseen toimintoja. Esimerkiksi \texttt{getChar}-funktio palauttaa siirr‰nt‰toiminnon joka lukee syˆtteest‰ yhden merkin. Vastaavasti \texttt{putChar}-funktio palauttaa toiminnon joka kirjoittaa merkin ulostuloon. Siirr‰nt‰toimintoja palauttavien funktioiden kutsut tulee sekvensoida \texttt{do}-operaattorin avulla. 

N‰in esimerkiksi yksinkertainen kaksi rivi‰ tulostava Haskell ohjelma olisi seuraavanlainen:
\begin{verbatim}
  main = do putStr "Hoi \n"
            putStr "maailma!"
\end{verbatim}

\section{Yhteenveto}
Funktionaalinen ohjelmointi on kehittynyt matemaattisesta formalismista varteenotettavaksi ohjelmointiparadigmaksi. Taustalla on halu saada ohjelmille esitysmuoto jossa ohjelmien oikeaksitodistaminen olisi helpompaa. Lis‰ksi funktionaalinen ohjelmointi tarjoaa voimakkaita korkean tason k‰sitteit‰ ohjelmien kirjoittamiseen ja ongelmien ratkontaan. 

Funktionaalisen ohjelmoinnin taustalla olevaa teoriaa kutsutaan lambda-laskennaksi. Lambda-laskenta kehitettiin alun perin formalismiksi jonka avulla voi esitt‰‰ kaikki laskettavissa olevat funktiot. Hyvin pian huomattiin ett‰ lambda-laskenta on ilmaisuvoimaltaan yht‰l‰inen Turingin koneiden kanssa. 

John McCarthy kehitti vuonna 1958 teko‰lyyn ja symboliseen laskentaan soveltuvan Lisp-kielen. McCarthy halusi kieleens‰ funktiot ensimm‰isen luokan arvoina, ja sopiva malli t‰h‰n lˆytyi lambda-laskennasta. Lisp ei kuitenkaan varsinaisesti ollut puhdas funktionaalinen ohjelmointikieli, koska se salli tilan. Toinen merkitt‰v‰ Lispin ominaisuus oli Lisp-koodin esitt‰minen Lisp-listoina. 

Lispin j‰lkeen on tullut monia muita kieli‰ jotka tukevat funktionaalista ohjelmointiparadigmaa. Merkitt‰vimm‰t n‰ist‰ lienev‰t Scheme, Erlang, Scala, ML ja Haskell. Haskell on alun alkaen suunniteltu puhtaaksi ja laiskaksi funktionaaliseksi kieleksi. Haskell on lis‰ksi vahvasti tyypitetty, monimuotoinen ja tukee tyyppien johtamista. 

Funktionaalisessa ohjelmoinnissa on tyypillist‰ ett‰ funktioita k‰sitell‰‰n ensimm‰isen luokan arvoina. Lista on m‰‰ritelty perustietorakenteena l‰hes kaikissa funktionaalista ohjelmointia tukevissa kieliss‰, samoin eri listaoperaatiot. Toisto saavutetaan rekursion avulla. Funktionaalisista ohjelmointikielist‰ Haskell tukee lausekkeiden laiskaa evaluaatiota, mik‰ on tehokkaampaa kuin tiukka evaluaatio, ja mahdollistaa p‰‰ttym‰ttˆm‰t tietorakenteet. Funktionaalisen mallin kannalta ongelmallinen siirr‰nt‰ on toteutettu Haskell-kieless‰ monadien avulla.  

\newpage

%%\nocite{*}
\bibliographystyle{tktl}
\bibliography{lahteet}

\lastpage

\appendices

\pagestyle{empty}

\end{document}
